[{"path":"https://fbertran.github.io/bigalgebra/articles/big-matrix-workflows.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Working with big.matrix Objects","text":"bigalgebra designed interoperate bigmemory ecosystem. vignette demonstrates create -memory file-backed big.matrix objects, interact via package’s wrappers, manage underlying resources safely.","code":""},{"path":"https://fbertran.github.io/bigalgebra/articles/big-matrix-workflows.html","id":"creating-in-memory-big-matrix-objects","dir":"Articles","previous_headings":"","what":"Creating in-memory big.matrix objects","title":"Working with big.matrix Objects","text":"-memory matrices behave much like ordinary R matrices reside shared memory, allowing multiple R sessions access data. created, objects can passed directly Level 1 helpers:","code":"X <- big.matrix(3, 3, type = \"double\", init = 0) X[,] <- matrix(1:9, nrow = 3) X[] #>      [,1] [,2] [,3] #> [1,]    1    4    7 #> [2,]    2    5    8 #> [3,]    3    6    9 dvcal(ALPHA = 2, X = X, BETA = -1, Y = X) X[] #>      [,1] [,2] [,3] #> [1,]    1    4    7 #> [2,]    2    5    8 #> [3,]    3    6    9"},{"path":"https://fbertran.github.io/bigalgebra/articles/big-matrix-workflows.html","id":"working-with-file-backed-matrices","dir":"Articles","previous_headings":"","what":"Working with file-backed matrices","title":"Working with big.matrix Objects","text":"File-backed matrices persist contents disk, making suitable data sets exceed available RAM. objects participate higher-level operations without loaded memory.","code":"dir.create(tmp_fb <- tempfile()) Y <- filebacked.big.matrix(4, 2, type = \"double\",                            backingpath = tmp_fb,                            backingfile = \"fb.bin\",                            descriptorfile = \"fb.desc\",                            init = 0) Y[,] <- matrix(runif(8), nrow = 4) Y[] #>            [,1]        [,2] #> [1,] 0.08075014 0.007399441 #> [2,] 0.83433304 0.466393497 #> [3,] 0.60076089 0.497777389 #> [4,] 0.15720844 0.289767245 Z <- filebacked.big.matrix(4, 2, type = \"double\",                            backingpath = tmp_fb,                            backingfile = \"res.bin\",                            descriptorfile = \"res.desc\",                            init = 0) dvcal(ALPHA = 1.5, X = Y, BETA = 0, Y = Z) Z[] #>           [,1]       [,2] #> [1,] 0.1211252 0.01109916 #> [2,] 1.2514996 0.69959025 #> [3,] 0.9011413 0.74666608 #> [4,] 0.2358127 0.43465087"},{"path":"https://fbertran.github.io/bigalgebra/articles/big-matrix-workflows.html","id":"sharing-matrices-between-sessions","dir":"Articles","previous_headings":"","what":"Sharing matrices between sessions","title":"Working with big.matrix Objects","text":"descriptor file records metadata needed reopen file-backed matrix new R session. attach.big.matrix() helper reconstructs object: operations performed via bigalgebra update shared backing file, allowing attached references observe change.","code":"Y_desc <- dget(file.path(tmp_fb, \"fb.desc\")) Y_again <- attach.big.matrix(Y_desc) identical(Y[,], Y_again[,]) #> [1] TRUE dsub(X = Z, Y = Y_again) Y_again[] #>             [,1]         [,2] #> [1,] -0.04037507 -0.003699721 #> [2,] -0.41716652 -0.233196749 #> [3,] -0.30038044 -0.248888694 #> [4,] -0.07860422 -0.144883622"},{"path":"https://fbertran.github.io/bigalgebra/articles/big-matrix-workflows.html","id":"cleaning-up-backing-files","dir":"Articles","previous_headings":"","what":"Cleaning up backing files","title":"Working with big.matrix Objects","text":"File-backed matrices allocate resources disk. Deleting backing descriptor files longer needed helps keep workspace tidy.","code":"unlink(file.path(tmp_fb, c(\"fb.bin\", \"fb.desc\", \"res.bin\", \"res.desc\"))) unlink(tmp_fb, recursive = TRUE)"},{"path":"https://fbertran.github.io/bigalgebra/articles/lapack-decompositions.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"LAPACK Decompositions with bigalgebra","text":"Beyond BLAS-level helpers, bigalgebra ships several wrappers around LAPACK routines factorisations can run -memory matrix objects file-backed [bigmemory::big.matrix] containers without changing workflows. vignette highlights four decompositions currently provided: dgeqrf() — QR factorisation driven Householder reflectors. dpotrf() — Cholesky factorisation symmetric positive definite matrices. dgeev() — real eigenvalues (optionally) eigenvectors general matrices. dgesdd() — divide--conquer singular value decomposition (SVD). example illustrates prepare workspace arguments, inspect results, clean temporary big.matrix files necessary.","code":""},{"path":"https://fbertran.github.io/bigalgebra/articles/lapack-decompositions.html","id":"qr-factorisation-with-dgeqrf","dir":"Articles","previous_headings":"","what":"QR factorisation with dgeqrf()","title":"LAPACK Decompositions with bigalgebra","text":"dgeqrf() helper overwrites input R factor upper triangle storing Householder reflector coefficients user-supplied TAU vector. Supplying TAU WORK explicitly makes easy inspect outputs afterwards. input file-backed, updates written directly disk factorisation scales matrices exceed available RAM.","code":"hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, \"+\") } H <- hilbert(4) H_big <- as.big.matrix(H) TAU <- matrix(0, nrow = min(nrow(H), ncol(H))) WORK <- matrix(0, nrow = max(1, ncol(H))) dgeqrf(A = H_big, TAU = TAU, WORK = WORK) #> [1] 0  # Extract the R factor from the overwritten big.matrix R_big <- H_big[,] R_big[lower.tri(R_big)] <- 0 R_big #>           [,1]       [,2]         [,3]          [,4] #> [1,] -1.193152 -0.6704931 -0.474932601 -0.3698354709 #> [2,]  0.000000 -0.1185333 -0.125655095 -0.1175419928 #> [3,]  0.000000  0.0000000 -0.006221774 -0.0095660929 #> [4,]  0.000000  0.0000000  0.000000000  0.0001879049  # Compare against base R's QR decomposition all.equal(R_big, qr.R(qr(H))) #> [1] TRUE TAU #>          [,1] #> [1,] 1.838116 #> [2,] 1.560868 #> [3,] 1.413383 #> [4,] 0.000000 tmp <- tempfile() H_fb <- filebacked.big.matrix(nrow(H), ncol(H), init = H,                               backingfile = basename(tmp),                               backingpath = dirname(tmp)) #> Warning in filebacked.big.matrix(nrow(H), ncol(H), init = H, backingfile = #> basename(tmp), : No descriptor file given, it will be named #> fileb50174135d2.desc dgeqrf(A = H_fb) #> [1] 0 H_fb[,][upper.tri(H_fb[,], diag = TRUE)] #>  [1] -2.000000e+00 -2.000000e+00 -9.614813e-17 -2.000000e+00 -9.614813e-17 #>  [6] -1.739150e-33 -2.000000e+00 -9.614813e-17 -1.739150e-33  4.056603e-49 rm(H_fb); gc() #>           used (Mb) gc trigger (Mb) limit (Mb) max used (Mb) #> Ncells  816477 43.7    1543642 82.5         NA  1543642 82.5 #> Vcells 1481039 11.3    8388608 64.0      65536  2969954 22.7"},{"path":"https://fbertran.github.io/bigalgebra/articles/lapack-decompositions.html","id":"cholesky-factorisation-with-dpotrf","dir":"Articles","previous_headings":"","what":"Cholesky factorisation with dpotrf()","title":"LAPACK Decompositions with bigalgebra","text":"dpotrf() computes -place Cholesky factorisation. helper returns 0 matrix positive definite leaves result selected triangle (upper default). input matrix positive definite, return value indicates leading minor failed can diagnose numerical issues proceeding downstream solves.","code":"set.seed(42) A <- matrix(rnorm(9), 3) SPD <- crossprod(A)  # symmetric positive definite SPD_big <- as.big.matrix(SPD) info <- dpotrf(UPLO = \"U\", A = SPD_big) info #> [1] 0  U <- SPD_big[,] U[lower.tri(U)] <- 0 all.equal(U, chol(SPD)) #> [1] TRUE"},{"path":"https://fbertran.github.io/bigalgebra/articles/lapack-decompositions.html","id":"eigenvalues-and-eigenvectors-via-dgeev","dir":"Articles","previous_headings":"","what":"Eigenvalues and eigenvectors via dgeev()","title":"LAPACK Decompositions with bigalgebra","text":"dgeev() wraps LAPACK’s general eigen solver accepts optional storage left right eigenvectors. default helper queries LAPACK optimal workspace size, making small examples straightforward. large matrices stored disk can pass big.matrix containers (optionally) VL/VR. wrapper automatically converts big storage native matrix arguments required.","code":"set.seed(123) M <- matrix(rnorm(16), 4) WR <- matrix(0, nrow = ncol(M)) WI <- matrix(0, nrow = ncol(M)) VL <- matrix(0, nrow = nrow(M), ncol = ncol(M)) dgeev(A = M, WR = WR, WI = WI, VL = VL) #> [1] 0  # Compare eigenvalues with base R complex_eigs <- WR[, 1] + 1i * WI[, 1] all.equal(sort(complex_eigs), sort(eigen(M)$values)) #> [1] TRUE"},{"path":"https://fbertran.github.io/bigalgebra/articles/lapack-decompositions.html","id":"singular-value-decomposition-with-dgesdd","dir":"Articles","previous_headings":"","what":"Singular value decomposition with dgesdd()","title":"LAPACK Decompositions with bigalgebra","text":"divide--conquer SVD routine dgesdd() requires workspace singular values (optionally) left right singular vectors. Providing big.matrix containers lets persist decompositions disk without copying R’s heap. dgesdd() accepts -memory file-backed matrices, enables scalable dimensionality reduction pipelines directly datasets larger available RAM.","code":"set.seed(101) X <- matrix(rnorm(12), 4) S <- matrix(0, nrow = min(dim(X))) U <- matrix(0, nrow = nrow(X), ncol = nrow(X)) VT <- matrix(0, nrow = ncol(X), ncol = ncol(X)) dgesdd(A = X, S = S, U = U, VT = VT) #> [1] 0  svd_base <- svd(X) all.equal(drop(S), svd_base$d) #> [1] \"Mean relative difference: 0.3311388\" all.equal(U, svd_base$u) #> [1] \"Attributes: < Component \\\"dim\\\": Mean relative difference: 0.25 >\" #> [2] \"Numeric: lengths (16, 12) differ\" all.equal(VT, t(svd_base$v)) #> [1] \"Mean relative difference: 1.484757\""},{"path":"https://fbertran.github.io/bigalgebra/articles/level-1-blas-style-helpers.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Level 1 BLAS-Style Helpers","text":"Level 1 BLAS routines operate vectors provide building blocks elaborate linear algebra workflows. bigalgebra package exposes collection convenience wrappers mirror classic operations extending work seamlessly [bigmemory::big.matrix] objects. vignette introduces helper, illustrating use base R vectors matrices backed disk.","code":""},{"path":"https://fbertran.github.io/bigalgebra/articles/level-1-blas-style-helpers.html","id":"filling-and-combining-vectors","dir":"Articles","previous_headings":"","what":"Filling and combining vectors","title":"Level 1 BLAS-Style Helpers","text":"helpers dset(), dvcal() dsub() operate place, making easy reuse pre-allocated storage working large data sets. either argument big.matrix, wrapper automatically keeps data disk still updating place:","code":"# Fill an existing matrix with a scalar X <- matrix(0, 2, 3) dset(ALPHA = 3.5, X = X) X #>      [,1] [,2] [,3] #> [1,]  3.5  3.5  3.5 #> [2,]  3.5  3.5  3.5  # Form alpha * X + beta * Y in place dx <- as.numeric(1:4) dy <- rep(2, 4) dvcal(ALPHA = 2, X = dx, BETA = -1, Y = dy) dy #> [1] 0 2 4 6  # Subtract X from Y element-wise dy2 <- rep(10, 4) dsub(X = dx, Y = dy2) dy2 #> [1] 9 8 7 6 library(bigmemory) # Allocate a file-backed big.matrix dir.create(tmp <- tempfile()) X_bm <- filebacked.big.matrix(4, 1, type = \"double\",                               backingfile = \"vec.bin\",                               backingpath = tmp,                               descriptorfile = \"vec.desc\") X_bm[] <- 0:3  dvcal(ALPHA = -1, X = X_bm, BETA = 2, Y = X_bm) X_bm[] #> [1] 0 1 2 3"},{"path":"https://fbertran.github.io/bigalgebra/articles/level-1-blas-style-helpers.html","id":"dot-products-and-element-wise-operations","dir":"Articles","previous_headings":"","what":"Dot products and element-wise operations","title":"Level 1 BLAS-Style Helpers","text":"ddot() evaluates standard dot product. problems numerical stability paramount, dqddot() accumulates extended precision. helper dhprod() forms Hadamard (element-wise) product returns populated output container. need transform entry vector matrix place, dsqrt() applies square root preserving original storage mode. three-dimensional vectors cross product helper dxyz() offers specialised convenience routine:","code":"# Classic dot product and its extended-precision counterpart v1 <- as.numeric(1:5) v2 <- seq(2, 10, by = 2) list(ddot = ddot(X = v1, Y = v2), dqddot = dqddot(X = v1, Y = v2)) #> $ddot #> [1] 110 #>  #> $dqddot #> [1] 110  # Hadamard product stored in a new matrix A <- matrix(as.numeric(1:4), 2, 2) B <- matrix(rep(2, 4), 2, 2) Z <- dhprod(X = A, Y = B) Z #>      [,1] [,2] #> [1,]    2    6 #> [2,]    4    8  # Element-wise square root performed in place sqrt_vals <- matrix(c(1, 4, 9, 16), 2) dsqrt(X = sqrt_vals) sqrt_vals #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 ux <- c(1, 0, 0) uy <- c(0, 1, 0) dxyz(X = ux, Y = uy) #> [1] 0 0 1"},{"path":"https://fbertran.github.io/bigalgebra/articles/level-1-blas-style-helpers.html","id":"reduction-helpers","dir":"Articles","previous_headings":"","what":"Reduction helpers","title":"Level 1 BLAS-Style Helpers","text":"reduction helpers mirror Level 1 BLAS routines computing sums, absolute sums, Euclidean norms cumulative products. return numeric scalars work strided access patterns via INCX parameter needed. id* family returns one-based indices extrema based value absolute value criteria. Level 1 helpers can combined higher-level matrix routines implement complex algorithms retaining performance benefits underlying compiled implementations.","code":"vals <- c(-1, 2, -3, 4) list(   sum = dsum(X = vals),   abs_sum = dasum(X = vals),   euclidean_norm = dnrm2(X = vals),   product = dprdct(X = vals) ) #> $sum #> [1] 2 #>  #> $abs_sum #> [1] 10 #>  #> $euclidean_norm #> [1] 5.477226 #>  #> $product #> [1] 24 idx_vals <- c(-2, 5, -7, 3) list(   min_index = idmin(X = idx_vals),   max_index = idmax(X = idx_vals),   min_abs_index = idamin(X = idx_vals),   max_abs_index = idamax(X = idx_vals) ) #> $min_index #> [1] 3 #>  #> $max_index #> [1] 2 #>  #> $min_abs_index #> [1] 1 #>  #> $max_abs_index #> [1] 3 unlink(file.path(tmp, \"vec.bin\")) unlink(file.path(tmp, \"vec.desc\")) unlink(tmp, recursive = TRUE)"},{"path":"https://fbertran.github.io/bigalgebra/articles/matrix-wrapper-helpers.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Matrix Wrapper Helpers","text":"Beyond Level 1 vector helpers, bigalgebra includes wrappers around Level 3 BLAS routines related utilities manipulating matrices stored memory [bigmemory::big.matrix] objects. vignette demonstrates core workflows symmetric matrix-matrix multiply dsymm(), general matrix multiply dgemm() AXPY-style updater daxpy().","code":""},{"path":"https://fbertran.github.io/bigalgebra/articles/matrix-wrapper-helpers.html","id":"symmetric-matrix-products-with-dsymm","dir":"Articles","previous_headings":"","what":"Symmetric matrix products with dsymm()","title":"Matrix Wrapper Helpers","text":"dsymm() mirrors BLAS symmetric matrix-matrix multiplication kernel. can multiply left right accepts optional leading-dimension arguments working non-standard strides. either input big.matrix, wrapper performs computation place without materialising intermediate R matrix.","code":"A_sym <- matrix(c(2, 1, 1, 3), 2, 2) B_rhs <- diag(2) C_out <- matrix(0, 2, 2) dsymm(A = A_sym, B = B_rhs, C = C_out, SIDE = \"L\", UPLO = \"U\") C_out #>      [,1] [,2] #> [1,]    2    1 #> [2,]    1    3 library(bigmemory) dir.create(tmp_sym <- tempfile()) A_bm <- filebacked.big.matrix(2, 2, type = \"double\",                               backingpath = tmp_sym,                               backingfile = \"A.bin\",                               descriptorfile = \"A.desc\") A_bm[,] <- A_sym B_bm <- filebacked.big.matrix(2, 2, type = \"double\",                               backingpath = tmp_sym,                               backingfile = \"B.bin\",                               descriptorfile = \"B.desc\") B_bm[,] <- B_rhs C_bm <- filebacked.big.matrix(2, 2, type = \"double\",                               backingpath = tmp_sym,                               backingfile = \"C.bin\",                               descriptorfile = \"C.desc\")  dsymm(A = A_bm, B = B_bm, C = C_bm) C_bm[] #>      [,1] [,2] #> [1,]    2    1 #> [2,]    1    3"},{"path":"https://fbertran.github.io/bigalgebra/articles/matrix-wrapper-helpers.html","id":"general-matrix-multiplication-with-dgemm","dir":"Articles","previous_headings":"","what":"General matrix multiplication with dgemm()","title":"Matrix Wrapper Helpers","text":"dgemm() exposes workhorse Level 3 BLAS routine computes C := alpha * op() %*% op(B) + beta * C. matrices can ordinary R matrices big.matrix objects, missing output created automatically. construct native R matrices, coerce integer literals doubles (example .numeric()) satisfy package’s double-precision requirement. Transposed operands also supported via TRANSA TRANSB:","code":"A <- matrix(as.numeric(1:6), nrow = 2) B <- matrix(seq(2, 12, by = 2), nrow = 3) C <- matrix(0, nrow = 2, ncol = 4) dgemm(TRANSA = \"N\", TRANSB = \"N\", A = A, B = B, C = C, BETA = 0) C #>      [,1] [,2] [,3] [,4] #> [1,]   44   98    0    0 #> [2,]   56  128    0    0 C_t <- matrix(0, nrow = 3, ncol = 3) dgemm(TRANSA = \"T\", TRANSB = \"N\", A = A, B = B, C = C_t, BETA = 0) C_t #>      [,1] [,2] [,3] #> [1,]   10   22    0 #> [2,]   22   50    0 #> [3,]   34   78    0"},{"path":"https://fbertran.github.io/bigalgebra/articles/matrix-wrapper-helpers.html","id":"updating-matrices-with-daxpy","dir":"Articles","previous_headings":"","what":"Updating matrices with daxpy()","title":"Matrix Wrapper Helpers","text":"daxpy() provides convenient wrapper AXPY operation Y := alpha * X + Y. helper respects package option bigalgebra.mixed_arithmetic_returns_R_matrix decide return native matrix versus big.matrix. operands big.matrix objects, result stays disk:","code":"X <- matrix(1, nrow = 2, ncol = 2) Y <- matrix(c(0, 1, 2, 3), nrow = 2) daxpy(A = 0.5, X = X, Y = Y) #> An object of class \"big.matrix\" #> Slot \"address\": #> <pointer: 0x155fcf7c0> dir.create(tmp_axpy <- tempfile()) X_bm <- filebacked.big.matrix(2, 2, type = \"double\",                               backingpath = tmp_axpy,                               backingfile = \"X.bin\",                               descriptorfile = \"X.desc\") X_bm[,] <- 1 daxpy(A = 3, X = X_bm) #> An object of class \"big.matrix\" #> Slot \"address\": #> <pointer: 0x155fdb6b0> X_bm[] #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 unlink(file.path(tmp_sym, c(\"A.bin\", \"A.desc\", \"B.bin\", \"B.desc\", \"C.bin\", \"C.desc\"))) unlink(tmp_sym, recursive = TRUE) unlink(file.path(tmp_axpy, c(\"X.bin\", \"X.desc\"))) unlink(tmp_axpy, recursive = TRUE)"},{"path":"https://fbertran.github.io/bigalgebra/articles/z_lapack-decompositions.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"LAPACK Decompositions with bigalgebra","text":"Beyond BLAS-level helpers, bigalgebra ships several wrappers around LAPACK routines factorisations can run -memory matrix objects file-backed [bigmemory::big.matrix] containers without changing workflows. vignette highlights four decompositions currently provided: dgeqrf() — QR factorisation driven Householder reflectors. dpotrf() — Cholesky factorisation symmetric positive definite matrices. dgeev() — real eigenvalues (optionally) eigenvectors general matrices. dgesdd() — divide--conquer singular value decomposition (SVD). example illustrates prepare workspace arguments, inspect results, clean temporary big.matrix files necessary.","code":""},{"path":"https://fbertran.github.io/bigalgebra/articles/z_lapack-decompositions.html","id":"qr-factorisation-with-dgeqrf","dir":"Articles","previous_headings":"","what":"QR factorisation with dgeqrf()","title":"LAPACK Decompositions with bigalgebra","text":"dgeqrf() helper overwrites input R factor upper triangle storing Householder reflector coefficients user-supplied TAU vector. Supplying TAU WORK explicitly makes easy inspect outputs afterwards. input file-backed, updates written directly disk factorisation scales matrices exceed available RAM.","code":"hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, \"+\") } H <- hilbert(4) H_big <- as.big.matrix(H) TAU <- matrix(0, nrow = min(nrow(H), ncol(H))) WORK <- matrix(0, nrow = max(1, ncol(H))) dgeqrf(A = H_big, TAU = TAU, WORK = WORK) #> [1] 0  # Extract the R factor from the overwritten big.matrix R_big <- H_big[,] R_big[lower.tri(R_big)] <- 0 R_big #>           [,1]       [,2]         [,3]          [,4] #> [1,] -1.193152 -0.6704931 -0.474932601 -0.3698354709 #> [2,]  0.000000 -0.1185333 -0.125655095 -0.1175419928 #> [3,]  0.000000  0.0000000 -0.006221774 -0.0095660929 #> [4,]  0.000000  0.0000000  0.000000000  0.0001879049  # Compare against base R's QR decomposition all.equal(R_big, qr.R(qr(H))) #> [1] TRUE TAU #>          [,1] #> [1,] 1.838116 #> [2,] 1.560868 #> [3,] 1.413383 #> [4,] 0.000000 tmp <- tempfile() H_fb <- filebacked.big.matrix(nrow(H), ncol(H), init = H,                               backingfile = basename(tmp),                               backingpath = dirname(tmp)) #> Warning in filebacked.big.matrix(nrow(H), ncol(H), init = H, backingfile = #> basename(tmp), : No descriptor file given, it will be named #> file2a91341560a0.desc dgeqrf(A = H_fb) #> [1] 0 H_fb[,][upper.tri(H_fb[,], diag = TRUE)] #>  [1] -2.000000e+00 -2.000000e+00 -9.614813e-17 -2.000000e+00 -9.614813e-17 #>  [6] -1.739150e-33 -2.000000e+00 -9.614813e-17 -1.739150e-33  4.056603e-49 rm(H_fb); gc() #>           used (Mb) gc trigger (Mb) limit (Mb) max used (Mb) #> Ncells  817060 43.7    1541750 82.4         NA  1541750 82.4 #> Vcells 1481869 11.4    8388608 64.0      65536  2981172 22.8"},{"path":"https://fbertran.github.io/bigalgebra/articles/z_lapack-decompositions.html","id":"cholesky-factorisation-with-dpotrf","dir":"Articles","previous_headings":"","what":"Cholesky factorisation with dpotrf()","title":"LAPACK Decompositions with bigalgebra","text":"dpotrf() computes -place Cholesky factorisation. helper returns 0 matrix positive definite leaves result selected triangle (upper default). input matrix positive definite, return value indicates leading minor failed can diagnose numerical issues proceeding downstream solves.","code":"set.seed(42) A <- matrix(rnorm(9), 3) SPD <- crossprod(A)  # symmetric positive definite SPD_big <- as.big.matrix(SPD) info <- dpotrf(UPLO = \"U\", A = SPD_big) info #> [1] 0  U <- SPD_big[,] U[lower.tri(U)] <- 0 all.equal(U, chol(SPD)) #> [1] TRUE"},{"path":"https://fbertran.github.io/bigalgebra/articles/z_lapack-decompositions.html","id":"eigenvalues-and-eigenvectors-via-dgeev","dir":"Articles","previous_headings":"","what":"Eigenvalues and eigenvectors via dgeev()","title":"LAPACK Decompositions with bigalgebra","text":"dgeev() wraps LAPACK’s general eigen solver accepts optional storage left right eigenvectors. default helper queries LAPACK optimal workspace size, making small examples straightforward. large matrices stored disk can pass big.matrix containers (optionally) VL/VR. wrapper automatically converts big storage native matrix arguments required.","code":"set.seed(123) M <- matrix(rnorm(16), 4) WR <- matrix(0, nrow = ncol(M)) WI <- matrix(0, nrow = ncol(M)) VL <- matrix(0, nrow = nrow(M), ncol = ncol(M)) dgeev(A = M, WR = WR, WI = WI, VL = VL) #> [1] 0  # Compare eigenvalues with base R complex_eigs <- WR[, 1] + 1i * WI[, 1] all.equal(sort(complex_eigs), sort(eigen(M)$values)) #> [1] TRUE"},{"path":"https://fbertran.github.io/bigalgebra/articles/z_lapack-decompositions.html","id":"singular-value-decomposition-with-dgesdd","dir":"Articles","previous_headings":"","what":"Singular value decomposition with dgesdd()","title":"LAPACK Decompositions with bigalgebra","text":"divide--conquer SVD routine dgesdd() requires workspace singular values (optionally) left right singular vectors. Providing big.matrix containers lets persist decompositions disk without copying R’s heap. dgesdd() accepts -memory file-backed matrices, enables scalable dimensionality reduction pipelines directly datasets larger available RAM.","code":"set.seed(101) X <- matrix(rnorm(12), 4) S <- matrix(0, nrow = min(dim(X))) U <- matrix(0, nrow = nrow(X), ncol = nrow(X)) VT <- matrix(0, nrow = ncol(X), ncol = ncol(X)) dgesdd(A = X, S = S, U = U, VT = VT) #> [1] 0  svd_base <- svd(X) all.equal(drop(S), svd_base$d) #> [1] \"Mean relative difference: 0.3311388\" all.equal(U, svd_base$u) #> [1] \"Attributes: < Component \\\"dim\\\": Mean relative difference: 0.25 >\" #> [2] \"Numeric: lengths (16, 12) differ\" all.equal(VT, t(svd_base$v)) #> [1] \"Mean relative difference: 1.484757\""},{"path":"https://fbertran.github.io/bigalgebra/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Frederic Bertrand. Maintainer, author. Michael J. Kane. Author. Bryan Lewis. Author. John W. Emerson. Author.","code":""},{"path":"https://fbertran.github.io/bigalgebra/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Frederic Bertrand, Michael J. Kane, John Emerson Stephen Weston(2025). 'BLAS' 'LAPACK' Routines Native R Matrices 'big.matrix' Objects, R package version 3.0.0. doi:10.32614/CRAN.package.bigalgebra. Michael J. Kane, John Emerson, Stephen Weston (2013). Scalable Strategies Computing Massive Data. Journal Statistical Software, 55(14), 1-19. doi: 10.18637/jss.v055.i14.","code":"@Manual{,   title = {'BLAS' and 'LAPACK' Routines for Native R Matrices and 'big.matrix' Objects},   author = {Frederic Bertrand and Michael J. Kane and John Emerson and Stephen Weston},   publisher = {manual},   year = {2025},   note = {R package version 3.0.0},   url = {https://fbertran.github.io/bigalgebra/}, } @Article{,   title = {Scalable Strategies for Computing with Massive Data},   author = {Michael J. Kane and John Emerson and Stephen Weston},   journal = {Journal of Statistical Software},   volume = {55},   issue = {14},   pages = {20},   year = {2013},   doi = {10.18637/jss.v055.i14}, }"},{"path":[]},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"frédéric-bertrand-michael-j-kane-bryan-lewis-john-w-emerson","dir":"","previous_headings":"","what":"Frédéric Bertrand, Michael J. Kane, Bryan Lewis, John W. Emerson","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"https://doi.org/10.32614/CRAN.package.bigalgebra bigalgebra provides fast linear algebra primitives operate seamlessly base matrix objects [bigmemory::big.matrix] containers. package wraps BLAS LAPACK routines R-friendly helpers vector updates, matrix products, classic decompositions work way memory disk.","code":""},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"package-highlights","dir":"","previous_headings":"","what":"Package highlights","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"big.matrix workflows – Guidance creating, sharing, cleaning file-backed matrices collected Working big.matrix Objects vignette. Vector kernels – Level 1 BLAS-style helpers dset(), dsub() ddot() extend familiar vector algebra big.matrix inputs. See Level 1 BLAS-Style Helpers vignette. Matrix products – Wrappers including dgemm() dsymm() expose Level 3 BLAS routines dense matrix multiplication optional file-backed outputs. Explore Matrix Wrapper Helpers vignette. LAPACK decompositions – QR, Cholesky, eigenvalue, SVD helpers (dgeqrf(), dpotrf(), dgeev(), dgesdd()) bring advanced factorisations large datasets. Walk LAPACK Decompositions vignette.","code":""},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"package-options","dir":"","previous_headings":"","what":"Package options","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"package defines number global options begin bigalgebra: Option Default value * bigalgebra.temp_pattern default matrix_ * bigalgebra.tempdir default tempdir * bigalgebra.mixed_arithmetic_returns_R_matrix default TRUE * bigalgebra.DEBUG default FALSE bigalgebra.tempdir option must function returns temporary directory path used store big matrix results BLAS LAPACK operations. default value simply base R tempdir() function. bigalgebra.temp_pattern option name prefix file names generated big matrix objects output result BLAS LAPACK operations. bigalgebra.mixed_arithmetic_returns_R_matrix option determines whether arithmetic operations involving R matrix vector big.matrix matrix vector return big matrix (option FALSE), return normal R matrix (TRUE).","code":""},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"blas-and-lapack-backends","dir":"","previous_headings":"","what":"BLAS and LAPACK backends","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"package built, default, R’s native BLAS libraries, use 32-bit signed integer indexing. default build limited vectors 2^31 − 1 entries matrices 2^31 − 1 rows 2^31 − 1 columns (note standard R matrices limited 2^31 − 1 total entries). package includes reference BLAS implementation supports 64-bit integer indexing, relaxing limitation vector lengths matrix row column limits. Installation package 64-bit reference BLAS implementation may performed command-line install: REFBLAS=1 R CMD INSTALL bigalgebra bigalgebra source package (example, bigalgebra_0.9.0.tar.gz). package may also built user-supplied external BLAS LAPACK libraries, either 32- 64-bit varieties. advanced topic requires additional Makevars modification, may include adjustment low-level calling syntax depending library used. Feel free contact us help installing running package. website, unit tests, C code fixes improvements well examples created F. Bertrand. Maintainer: Frédéric Bertrand frederic.bertrand@lecnam.net.","code":""},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"can install released version bigalgebra CRAN : can install development version bigalgebra GitHub :","code":"install.packages(\"bigalgebra\") devtools::install_github(\"fbertran/bigalgebra\")"},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"quick-tour-of-the-functionality","dir":"","previous_headings":"","what":"Quick tour of the functionality","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"snippets mirror worked examples vignettes show helpers behave -memory file-backed matrices.","code":""},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"level-1-blas-helpers","dir":"","previous_headings":"Quick tour of the functionality","what":"Level 1 BLAS helpers","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"helpers cover vector updates, reductions, element-wise transforms -place square root provided dsqrt().","code":"library(bigmemory) library(bigalgebra)  x <- bigmemory::big.matrix(5, 1, init = 0) dset(ALPHA = 9, X = x) dsqrt(X = x) x[] #> [1] 3 3 3 3 3  y <- bigmemory::big.matrix(5, 1, init = 1) dvcal(ALPHA = 0.5, X = x, BETA = 2, Y = y) y[] #> [1] 3.5 3.5 3.5 3.5 3.5"},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"matrix-products-with-dgemm","dir":"","previous_headings":"Quick tour of the functionality","what":"Matrix products with dgemm()","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"","code":"A <- bigmemory::big.matrix(5, 4, init = 1) B <- bigmemory::big.matrix(4, 4, init = 2) C <- bigmemory::big.matrix(5, 4, init = 0)  dgemm(A = A, B = B, C = C, ALPHA = 1, BETA = 0) C[] #>      [,1] [,2] [,3] [,4] #> [1,]    8    8    8    8 #> [2,]    8    8    8    8 #> [3,]    8    8    8    8 #> [4,]    8    8    8    8 #> [5,]    8    8    8    8"},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"lapack-decompositions","dir":"","previous_headings":"Quick tour of the functionality","what":"LAPACK decompositions","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"","code":"set.seed(1) M <- matrix(rnorm(9), 3) SPD <- crossprod(M) SPD_big <- as.big.matrix(SPD) dpotrf(A = SPD_big) #> [1] 0 chol_factor <- SPD_big[,] chol_factor[lower.tri(chol_factor)] <- 0 chol_factor #>          [,1]       [,2]       [,3] #> [1,] 1.060398 -0.2388263 -0.6138286 #> [2,] 0.000000  1.8082109  0.2222424 #> [3,] 0.000000  0.0000000  0.8294922"},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"file-backed-bigmatrix-workflows","dir":"","previous_headings":"Quick tour of the functionality","what":"File-backed big.matrix workflows","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"","code":"tmpdir <- tempdir() file_big <- filebacked.big.matrix(3, 3, init = diag(3),                                   backingpath = tmpdir,                                   backingfile = \"example.bin\") #> Warning in filebacked.big.matrix(3, 3, init = diag(3), backingpath = tmpdir, : No #> descriptor file given, it will be named example.bin.desc file_big[1, 3] <- 5 file_big[] #>      [,1] [,2] [,3] #> [1,]    1    1    5 #> [2,]    1    1    1 #> [3,]    1    1    1 rm(file_big) gc() #>           used (Mb) gc trigger (Mb) limit (Mb) max used (Mb) #> Ncells  900616 48.1    1699095 90.8         NA  1377768 73.6 #> Vcells 2253326 17.2    8388608 64.0      65536  3247956 24.8"},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"available-vignettes","dir":"","previous_headings":"","what":"Available vignettes","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"full vignette set expands topics demonstrates routines interact: Working big.matrix Objects – Managing shared memory, file backing, clean-large datasets. Level 1 BLAS-Style Helpers – Filling vectors, Hadamard products, reductions disk-backed data. Matrix Wrapper Helpers – Symmetric general matrix products, including strategies chaining operations. LAPACK Decompositions bigalgebra – QR, Cholesky, eigenvalue, SVD workflows -memory file-backed matrices.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Arithmetic operations big.matrices","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"%*% signature{x=\"big.matrix\", y=\"big.matrix\"}: ... %*% signature{x=\"matrix\", y=\"big.matrix\"}: ... %*% signature{x=\"big.matrix\", y=\"matrix\"}: ... Arith signature{x=\"big.matrix\", y=\"big.matrix\"}: ... Arith signature{x=\"big.matrix\", y=\"matrix\"}: ... Arith signature{x=\"matrix\", y=\"big.matrix\"}: ... Arith signature{x=\"big.matrix\", y=\"numeric\"}: ... Arith signature{x=\"numeric\", y=\"big.matrix\"}: ...","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Class ","text":"Miscellaneous arithmetic methods matrices big.matrices. See also options(\"bigalgebra.mixed_arithmetic_returns_R_matrix\").","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class ","text":"B. W. Lewis <blewis@illposed.net>","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"package provides arithmetic functions native R matrices big.matrix objects.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"package provides arithmetic functions native R matrices big.matrix objects. package defines number global options begin bigalgebra. include: bigalgebra.tempdir option must function returns temporary directory path used big matrix results BLAS LAPACK operations. deault value simply default R tempdir function. bigalgebra.temp_pattern name prefix file names generated big matrix objects output result BLAS LAPACK operations. bigalgebra.mixed_arithmetic_returns_R_matrix option determines whether arithmetic operations involving R matrix vector big.matrix matrix vector return big matrix (option FALSE), return normal R matrix (TRUE). package built, default, R's native BLAS libraries, use 32-bit signed integer indexing. default build limited vectors 2**31 - 1 entries matrices 2**31 - 1 rows 2**31 - 1 columns (note standard R matrices limtied 2**31 - 1 total entries). package includes reference BLAS implementation supports 64-bit integer indexing, relaxing limitation vector lengths matrix row column limits. Installation package 64-bit reference BLAS implementation may performed command-line install: REFBLAS=1 R CMD INSTALL bigalgebra \"bigalgebra\" source package (example, bigalgebra_0.8.4.tar.gz). package may also build user-supplied external BLAS LAPACK libraries, either 32- 64-bit varieties. advanced topic requires additional Makevars modification, may include adjustment low-level calling syntax depending library used. Feel free contact us help installing running package.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"Frédéric Bertrand, Michael J. Kane, Bryan Lewis, John W. Emerson Maintainer: Frédéric Bertrand <frederic.bertrand@lecnam.net>","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"https://www.netlib.org/blas/ https://www.netlib.org/lapack/","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"","code":"# Testing the development of the user-friendly operators: # if you have any problems, please email us!  - Jay & Mike 4/29/2010  library(\"bigmemory\") A <- big.matrix(5,4, type=\"double\", init=0,                 dimnames=list(NULL, c(\"alpha\", \"beta\"))) B <- big.matrix(4,4, type=\"double\", init=0,                 dimnames=list(NULL, c(\"alpha\", \"beta\")))  C <- A  D <- A[]   print(C - D)       # Compare the results (subtraction of an R matrix from a #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #> [5,]    0    0    0    0                    # big.matrix)  # The next example illustrates mixing R and big.matrix objects. It returns by # default (see # options(\"bigalgebra.mixed_arithmetic_returns_R_matrix\") D <- matrix(rnorm(16),4) E <- A"},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":null,"dir":"Reference","previous_headings":"","what":"Add two double-precision vectors. — dadd","title":"Add two double-precision vectors. — dadd","text":"Compute double precision DY := DX + DY N elements, applying specified storage increments. routine mirrors BLAS DAXPY operation unit scaling factor.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add two double-precision vectors. — dadd","text":"","code":"dadd(N = NULL, X, INCX = 1L, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add two double-precision vectors. — dadd","text":"N number elements input vectors. Defaults length X NULL. X double precision vector matrix providing addend. INCX storage spacing elements X. Y double precision vector matrix updated place. INCY storage spacing elements Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add two double-precision vectors. — dadd","text":"modified object Y containing element-wise sums.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add two double-precision vectors. — dadd","text":"implementation delegates BLAS DAXPY routine unit scaling factor, making equivalent daxpy(1.0, X, Y) exposing interface consistent low-level wrappers dcopy dscal.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add two double-precision vectors. — dadd","text":"","code":"set.seed(4669) X <- matrix(runif(6), 3, 2) Y <- matrix(runif(6), 3, 2) dadd(X = X, Y = Y) #>           [,1]     [,2] #> [1,] 0.8373056 1.273518 #> [2,] 0.9437275 1.347313 #> [3,] 1.0879022 1.192258 all.equal(Y, X + Y) #> [1] \"Mean relative difference: 0.5023438\""},{"path":"https://fbertran.github.io/bigalgebra/reference/dasum.html","id":null,"dir":"Reference","previous_headings":"","what":"Sum of absolute values — dasum","title":"Sum of absolute values — dasum","text":"Sum absolute values","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dasum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sum of absolute values — dasum","text":"","code":"dasum(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dasum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sum of absolute values — dasum","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dasum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sum of absolute values — dasum","text":"Numeric scalar.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":null,"dir":"Reference","previous_headings":"","what":"BLAS daxpy functionality — daxpy","title":"BLAS daxpy functionality — daxpy","text":"function implements function Y := * X + Y X Y may either native double-precision valued R matrices numeric vectors, double-precision valued big.matrix objects, scalar.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BLAS daxpy functionality — daxpy","text":"","code":"daxpy(A = 1, X, Y)"},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BLAS daxpy functionality — daxpy","text":"Optional numeric scalar value scale matrix X , default value 1. X Requried either native R matrix numeric vector, big.matrix object Y Optional native R matrix numeric vector, big.matrix object","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BLAS daxpy functionality — daxpy","text":"output value depends classes input values X Y value global option bigalgebra.mixed_arithmetic_returns_R_matrix. X Y big matrices, Y missing, options(\"bigalgebra.mixed_arithmetic_returns_R_matrix\") FALSE, big.matrix returned. returned big.matrix backed temporary file mapping deleted returned result garbage collected R (see examples). Otherwise, standard R matrix returned. dimensional shape output taken X. input X dimensionless (, lacks dimension attribute), output column vector.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BLAS daxpy functionality — daxpy","text":"least one either X Y must big.matrix. values must type double (type presently supported bigalgebra package). function rarely necessary use directly since bigalgebra package defines standard arithmetic operations scalar multiplication. efficient use daxpy directly scaling matrix addition required, case operations performed one step.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"BLAS daxpy functionality — daxpy","text":"https://www.netlib.org/blas/daxpy.f","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BLAS daxpy functionality — daxpy","text":"Michael J. Kane","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BLAS daxpy functionality — daxpy","text":"","code":"require(bigmemory) A = matrix(1, nrow=3, ncol=2) B <- big.matrix(3, 2, type=\"double\", init=0,                 dimnames=list(NULL, c(\"alpha\", \"beta\")), shared=FALSE) C = B + B   # C is a new big matrix D = A + B   # D defaults to a regular R matrix, to change this, set the option: # options(bigalgebra.mixed_arithmetic_returns_R_matrix=FALSE) E = daxpy(A=1.0, X=B, Y=B)  # Same kind of result as C print(C[]) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 print(D) #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #> [3,]    1    1 print(E[]) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0  # The C and E big.matrix file backings will be deleted when garbage collected: # (We enable debugging to see this explicitly) options(bigalgebra.DEBUG=TRUE) rm(C,E) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1147699 61.3    2286010 122.1         NA  2286010 122.1 #> Vcells 2053999 15.7    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy a vector. — dcopy","title":"Copy a vector. — dcopy","text":"Copy double precision DX double precision DY. = 0 N-1, copy DX(LX+*INCX) DY(LY+*INCY), LX = 1 INCX .GE. 0, else LX = 1+(1-N)*INCX, LY defined similar way using INCY.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy a vector. — dcopy","text":"","code":"dcopy(N = NULL, X, INCX = 1, Y, INCY = 1)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy a vector. — dcopy","text":"N number elements input vector(s) X double precision vector N elements INCX storage spacing elements DX Y double precision vector N elements INCY storage spacing elements DY","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy a vector. — dcopy","text":"DY copy vector DX (unchanged N .LE. 0)","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Copy a vector. — dcopy","text":"C. L. Lawson, R. J. Hanson, D. R. Kincaid F. T. Krogh, Basic linear algebra subprograms Fortran usage, Algorithm . 539, Transactions Mathematical Software 5, 3 (September 1979), pp. 308-323.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copy a vector. — dcopy","text":"","code":"set.seed(4669) A = big.matrix(3, 2, type=\"double\", init=1, dimnames=list(NULL,  c(\"alpha\", \"beta\")), shared=FALSE) B = big.matrix(3, 2, type=\"double\", init=0, dimnames=list(NULL,  c(\"alpha\", \"beta\")), shared=FALSE)  dcopy(X=A,Y=B) #> [1] 0 A[,]-B[,] #>      alpha beta #> [1,]     0    0 #> [2,]     0    0 #> [3,]     0    0  # The big.matrix file backings will be deleted when garbage collected. rm(A,B) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1147654 61.3    2286010 122.1         NA  2286010 122.1 #> Vcells 2052770 15.7    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/ddot.html","id":null,"dir":"Reference","previous_headings":"","what":"Dot product of two vectors — ddot","title":"Dot product of two vectors — ddot","text":"Dot product two vectors","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/ddot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dot product of two vectors — ddot","text":"","code":"ddot(N = NULL, X, INCX = 1L, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/ddot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dot product of two vectors — ddot","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`. Y Double-precision object updated place. INCY Integer stride traversing `Y`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/ddot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dot product of two vectors — ddot","text":"Numeric scalar containing dot product.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/ddot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dot product of two vectors — ddot","text":"","code":"ddot(X = 1:3, Y = c(2, 4, 6)) #> [1] 28"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":null,"dir":"Reference","previous_headings":"","what":"DGEEV computes eigenvalues and eigenvectors. — dgeev","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"DGEEV computes eigenvalues , optionally, left /right eigenvectors GE matrices. DGEEV computes N--N real nonsymmetric matrix , eigenvalues , optionally, left /right eigenvectors. right eigenvector v(j) satisfies * v(j) = lambda(j) * v(j) lambda(j) eigenvalue. left eigenvector u(j) satisfies u(j)**H * = lambda(j) * u(j)**H u(j)**H denotes conjugate-transpose u(j). computed eigenvectors normalized Euclidean norm equal 1 largest component real.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"","code":"dgeev(   JOBVL = NULL,   JOBVR = NULL,   N = NULL,   A,   LDA = NULL,   WR,   WI,   VL = NULL,   LDVL = NULL,   VR = NULL,   LDVR = NULL,   WORK = NULL,   LWORK = NULL )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"JOBVL character. = 'N': left eigenvectors computed; = 'V': left eigenvectors computed. JOBVR character. = 'N': right eigenvectors computed; = 'V': right eigenvectors computed. N integer. order matrix . N >= 0. matrix dimension (LDA,N), N--N matrix . LDA integer. leading dimension matrix . LDA >= max(1,N). WR vector dimension (N). WR contain real part computed eigenvalues. Complex conjugate pairs eigenvalues appear consecutively eigenvalue positive imaginary part first. WI vector dimension (N). WI contain imaginary part computed eigenvalues. Complex conjugate pairs eigenvalues appear consecutively eigenvalue positive imaginary part first. VL matrx dimension (LDVL,N) JOBVL = 'V', left eigenvectors u(j) stored one   another columns VL, order   eigenvalues. JOBVL = 'N', VL referenced. j-th eigenvalue real, u(j) = VL(:,j),   j-th column VL. j-th (j+1)-st eigenvalues form complex   conjugate pair, u(j) = VL(:,j) + *VL(:,j+1)   u(j+1) = VL(:,j) - *VL(:,j+1). LDVL integer. leading dimension array VL. LDVL >= 1; JOBVL = 'V', LDVL >= N. VR matrix dimension (LDVR,N). JOBVR = 'V', right eigenvectors v(j) stored one another columns VR, order eigenvalues. JOBVR = 'N', VR referenced. j-th eigenvalue real, v(j) = VR(:,j), j-th column VR. j-th (j+1)-st eigenvalues form complex conjugate pair, v(j) = VR(:,j) + *VR(:,j+1) v(j+1) = VR(:,j) - *VR(:,j+1). LDVR integer. leading dimension array VR.  LDVR >= 1; JOBVR = 'V', LDVR >= N. WORK matrix dimension (MAX(1,LWORK)) LWORK integer. dimension array WORK.LWORK >= max(1,3*N), JOBVL = 'V' JOBVR = 'V', LWORK >= 4*N. good performance, LWORK must generally larger. LWORK = -1, workspace query assumed; routine calculates optimal size WORK array, returns value first entry WORK array, error message related LWORK issued XERBLA.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"WR, WI, VR, VL Work. exit, overwritten.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"","code":"set.seed(4669) A = matrix(rnorm(16),4) WR= matrix(0,nrow=4,ncol=1) WI= matrix(0,nrow=4,ncol=1) VL = matrix(0,ncol=4,nrow=4) eigen(A) #> eigen() decomposition #> $values #> [1]  0.85730911+1.690442i  0.85730911-1.690442i -0.86120947+0.000000i #> [4] -0.04044732+0.000000i #>  #> $vectors #>                         [,1]                    [,2]          [,3] #> [1,] -0.20131416-0.08051662i -0.20131416+0.08051662i -0.4396218+0i #> [2,] -0.73251338+0.00000000i -0.73251338+0.00000000i  0.4547709+0i #> [3,] -0.06644069-0.55880008i -0.06644069+0.55880008i -0.1693250+0i #> [4,]  0.22714677+0.21942261i  0.22714677-0.21942261i -0.7558076+0i #>               [,4] #> [1,] -0.9125418+0i #> [2,] -0.2656930+0i #> [3,]  0.2527695+0i #> [4,]  0.1810590+0i #>  dgeev(A=A,WR=WR,WI=WI,VL=VL) #> [1] 0 VL #>              [,1]       [,2]       [,3]       [,4] #> [1,] -0.099694024  0.1149983 -0.2126753 -0.7057922 #> [2,]  0.657326284  0.0000000 -0.1918649  0.3331385 #> [3,]  0.007357843  0.5515939 -0.3234797  0.3139870 #> [4,]  0.451853982 -0.1904644 -0.9018414  0.5406369 WR #>             [,1] #> [1,]  0.85730911 #> [2,]  0.85730911 #> [3,] -0.86120947 #> [4,] -0.04044732 WI #>           [,1] #> [1,]  1.690442 #> [2,] -1.690442 #> [3,]  0.000000 #> [4,]  0.000000  rm(A,WR,WI,VL)  A = as.big.matrix(matrix(rnorm(16),4)) WR= matrix(0,nrow=4,ncol=1) WI= matrix(0,nrow=4,ncol=1) VL = as.big.matrix(matrix(0,ncol=4,nrow=4)) eigen(A[,]) #> eigen() decomposition #> $values #> [1] -0.7802559+0.6873447i -0.7802559-0.6873447i  0.6930662+0.4810716i #> [4]  0.6930662-0.4810716i #>  #> $vectors #>                       [,1]                  [,2]                   [,3] #> [1,]  0.1471182+0.4334710i  0.1471182-0.4334710i -0.2986975+0.07375248i #> [2,]  0.2638302+0.1607608i  0.2638302-0.1607608i -0.4446219-0.18640256i #> [3,] -0.4094915+0.0733955i -0.4094915-0.0733955i  0.7778787+0.00000000i #> [4,] -0.7224532+0.0000000i -0.7224532+0.0000000i  0.2526100-0.06323534i #>                        [,4] #> [1,] -0.2986975-0.07375248i #> [2,] -0.4446219+0.18640256i #> [3,]  0.7778787+0.00000000i #> [4,]  0.2526100+0.06323534i #>  dgeev(A=A,WR=WR,WI=WI,VL=VL) #> [1] 0 VL[,] #>             [,1]       [,2]        [,3]        [,4] #> [1,] -0.63149291  0.0000000 -0.35751797 -0.04531232 #> [2,] -0.22007417  0.1890068  0.81587447  0.00000000 #> [3,] -0.33976651  0.2889619  0.32444761  0.26761276 #> [4,] -0.08779556 -0.5571465  0.04124336 -0.16091204 WR[,] #> [1] -0.7802559 -0.7802559  0.6930662  0.6930662 WI[,] #> [1]  0.6873447 -0.6873447  0.4810716 -0.4810716  rm(A,WR,WI,VL) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1149161 61.4    2286010 122.1         NA  2286010 122.1 #> Vcells 2056469 15.7    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Multiply — dgemm","title":"Matrix Multiply — dgemm","text":"function provides dgemm functionality, DGEMM performs one matrix-matrix operations. C := ALPHA * op() * op(B) + BETA * C.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Multiply — dgemm","text":"","code":"dgemm(   TRANSA = \"N\",   TRANSB = \"N\",   M = NULL,   N = NULL,   K = NULL,   ALPHA = 1,   A,   LDA = NULL,   B,   LDB = NULL,   BETA = 0,   C,   LDC = NULL,   COFF = 0 )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Multiply — dgemm","text":"TRANSA character. TRANSA specifies form op( ) used matrix multiplication follows: TRANSA = 'N' 'n',  op( ) = . TRANSA = 'T' 't',  op( ) = **T. TRANSA = 'C' 'c',  op( ) = **T. TRANSB character. TRANSB specifies form op( B ) used matrix multiplication follows: #' TRANSA = 'N' 'n',  op( B ) = B. TRANSA = 'T' 't',  op( B ) = B**T. TRANSA = 'C' 'c',  op( B ) = B**T. M integer. M specifies number rows   matrix op( )   matrix  C.  M  must  least  zero. N integer. N specifies number columns   matrix op( B )   matrix  C.  N  must  least  zero. K integer. K specifies number columns   matrix op( )  number rows  matrix  op( B ).  K  must  least  zero. ALPHA real number. Specifies scalar alpha. matrix dimension (LDA, ka), ka k   TRANSA = 'N' 'n',   m  otherwise. entry  TRANSA = 'N' 'n',  leading  m k part array   must contain matrix  ,  otherwise leading  k m  part array   must contain  matrix . LDA integer. B matrix dimension ( LDB, kb ), kb n   TRANSB = 'N' 'n',   k  otherwise. entry  TRANSB = 'N' 'n',  leading  k n part array  B  must contain matrix  B,  otherwise leading  n k  part array  B  must contain  matrix B. LDB integer. BETA real number. Specifies scalar beta C matrix dimension ( LDC, N ). entry, leading  m n  part array  C must contain matrix  C,  except  beta  zero, case C need set entry. exit, array  C  overwritten  m n  matrix ( alpha*op( )*op( B ) + beta*C ). LDC integer. COFF offset C.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Multiply — dgemm","text":"Update C result.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Multiply — dgemm","text":"","code":"require(bigmemory) A = as.big.matrix(matrix(1, nrow=3, ncol=2)) B <- big.matrix(2, 3, type=\"double\", init=-1,                 dimnames=list(NULL, c(\"alpha\", \"beta\")), shared=FALSE) C = big.matrix(3, 3, type=\"double\", init=1,                dimnames=list(NULL, c(\"alpha\", \"beta\", \"gamma\")), shared=FALSE)   2*A[,]%*%B[,]+0.5*C[,] #>      alpha beta gamma #> [1,]  -3.5 -3.5  -3.5 #> [2,]  -3.5 -3.5  -3.5 #> [3,]  -3.5 -3.5  -3.5 E = dgemm(ALPHA=2.0, A=A, B=B, BETA=0.5, C=C) E[,] # Same result #>      alpha beta gamma #> [1,]  -3.5 -3.5  -3.5 #> [2,]  -3.5 -3.5  -3.5 #> [3,]  -3.5 -3.5  -3.5  # The big.matrix file backings will be deleted when garbage collected. rm(A,B,C,E) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1149438 61.4    2286010 122.1         NA  2286010 122.1 #> Vcells 2056964 15.7    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":null,"dir":"Reference","previous_headings":"","what":"QR factorization — dgeqrf","title":"QR factorization — dgeqrf","text":"DGEQRF computes QR factorization real M--N matrix : = Q * R.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"QR factorization — dgeqrf","text":"","code":"dgeqrf(   M = NULL,   N = NULL,   A,   LDA = NULL,   TAU = NULL,   WORK = NULL,   LWORK = NULL )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"QR factorization — dgeqrf","text":"M integer. number rows matrix .  M >= 0. N integer. number columns matrix .  N >= 0. M--N big matrix . LDA integer. leading dimension array .  LDA >= max(1,M). TAU min(M,N) matrix. scalar factors elementary reflectors. WORK (MAX(1,LWORK)) matrix. exit, INFO = 0, WORK(1) returns optimal LWORK. LWORK integer. dimension th array WORK.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"QR factorization — dgeqrf","text":"M--N big matrix . elements diagonal array contain min(M,N)--N upper trapezoidal matrix R (R upper triangular m >= n); elements diagonal, array TAU, represent orthogonal matrix Q product min(m,n) elementary reflectors.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"QR factorization — dgeqrf","text":"","code":"hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, \"+\") } h9 <- hilbert(9); h9 #>            [,1]      [,2]       [,3]       [,4]       [,5]       [,6] #>  [1,] 1.0000000 0.5000000 0.33333333 0.25000000 0.20000000 0.16666667 #>  [2,] 0.5000000 0.3333333 0.25000000 0.20000000 0.16666667 0.14285714 #>  [3,] 0.3333333 0.2500000 0.20000000 0.16666667 0.14285714 0.12500000 #>  [4,] 0.2500000 0.2000000 0.16666667 0.14285714 0.12500000 0.11111111 #>  [5,] 0.2000000 0.1666667 0.14285714 0.12500000 0.11111111 0.10000000 #>  [6,] 0.1666667 0.1428571 0.12500000 0.11111111 0.10000000 0.09090909 #>  [7,] 0.1428571 0.1250000 0.11111111 0.10000000 0.09090909 0.08333333 #>  [8,] 0.1250000 0.1111111 0.10000000 0.09090909 0.08333333 0.07692308 #>  [9,] 0.1111111 0.1000000 0.09090909 0.08333333 0.07692308 0.07142857 #>             [,7]       [,8]       [,9] #>  [1,] 0.14285714 0.12500000 0.11111111 #>  [2,] 0.12500000 0.11111111 0.10000000 #>  [3,] 0.11111111 0.10000000 0.09090909 #>  [4,] 0.10000000 0.09090909 0.08333333 #>  [5,] 0.09090909 0.08333333 0.07692308 #>  [6,] 0.08333333 0.07692308 0.07142857 #>  [7,] 0.07692308 0.07142857 0.06666667 #>  [8,] 0.07142857 0.06666667 0.06250000 #>  [9,] 0.06666667 0.06250000 0.05882353 qr(h9)$rank           #--> only 7 #> [1] 7 qrh9 <- qr(h9, tol = 1e-10) qrh9$rank  #> [1] 9 C <- as.big.matrix(h9) dgeqrf(A=C) #> [1] 0  # The big.matrix file backings will be deleted when garbage collected. rm(C) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1150291 61.5    2286010 122.1         NA  2286010 122.1 #> Vcells 2059149 15.8    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":null,"dir":"Reference","previous_headings":"","what":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"DGESDD computes singular value decomposition (SVD) real M--N matrix , optionally computing left right singular vectors.  singular vectors desired, uses divide--conquer algorithm. SVD written = U * SIGMA * transpose(V) SIGMA M--N matrix zero except min(m,n) diagonal elements, U M--M orthogonal matrix, V N--N orthogonal matrix.  diagonal elements SIGMA singular values ; real non-negative, returned descending order.  first min(m,n) columns U V left right singular vectors . Note routine returns VT = V**T, V.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"","code":"dgesdd(   JOBZ = \"A\",   M = NULL,   N = NULL,   A,   LDA = NULL,   S,   U,   LDU = NULL,   VT,   LDVT = NULL,   WORK = NULL,   LWORK = NULL )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"JOBZ character. Specifies options computing part matrix U: = '': M columns U N rows V**T returned arrays U VT; = 'S': first min(M,N) columns U first min(M,N) rows V**T returned arrays U VT; = 'O': M >= N, first N columns U overwritten array rows V**T returned array VT; otherwise, columns U returned array U first M rows V**T overwritten array ; = 'N': columns U rows V**T computed. M integer. number rows input matrix . M >= 0. N integer. number columns input matrix . N >= 0. M--N matrix . LDA integer. leading dimension matrix .  LDA >= max(1,M). S matrix dimension (min(M,N)). singular values , sorted S() >= S(+1). U U matrx dimension (LDU,UCOL) UCOL = M JOBZ = '' JOBZ = 'O' M < N; UCOL = min(M,N) JOBZ = 'S'. JOBZ = '' JOBZ = 'O' M < N, U contains M--M orthogonal matrix U; JOBZ = 'S', U contains first min(M,N) columns U (left singular vectors, stored columnwise); JOBZ = 'O' M >= N, JOBZ = 'N', U referenced. LDU integer. leading dimension matrix U.  LDU >= 1; JOBZ = 'S' '' JOBZ = 'O' M < N, LDU >= M. VT VT matrix dimension (LDVT,N) JOBZ = '' JOBZ = 'O' M >= N, VT contains N--N orthogonal matrix V**T; JOBZ = 'S', VT contains first min(M,N) rows V**T (right singular vectors, stored rowwise); JOBZ = 'O' M < N, JOBZ = 'N', VT referenced. LDVT integer. leading dimension matrix VT.  LDVT >= 1; JOBZ = '' JOBZ = 'O' M >= N, LDVT >= N; JOBZ = 'S', LDVT >= min(M,N). WORK matrix dimension (MAX(1,LWORK)) LWORK integer. dimension array WORK. LWORK >= 1. LWORK = -1, workspace query assumed.  optimal size WORK array calculated stored WORK(1), work except argument checking performed. Let mx = max(M,N) mn = min(M,N). JOBZ = 'N', LWORK >= 3*mn + max( mx, 7*mn ). JOBZ = 'O', LWORK >= 3*mn + max( mx, 5*mn*mn + 4*mn ). JOBZ = 'S', LWORK >= 4*mn*mn + 7*mn. JOBZ = '', LWORK >= 4*mn*mn + 6*mn + mx. tight minimums cases; see comments inside code.  good performance, LWORK generally larger;  query recommended.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"IWORK integer matrix dimension (8*min(M,N)) updated. JOBZ = 'O',  overwritten first N columns U (left singular vectors, stored columnwise) M >= N; overwritten first M rows V**T (right singular vectors, stored rowwise) otherwise. JOBZ .ne. 'O', contents destroyed. INFO integer = 0: successful exit. < 0: INFO = -, -th argument illegal value. > 0: DBDSDC converge, updating process failed.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"","code":"set.seed(4669) A = matrix(rnorm(12),4,3) S = matrix(0,nrow=3,ncol=1) U = matrix(0,nrow=4,ncol=4) VT = matrix(0,ncol=3,nrow=3) dgesdd(A=A,S=S,U=U,VT=VT) #> [1] 0 S #>           [,1] #> [1,] 2.5683690 #> [2,] 1.9865047 #> [3,] 0.1726739 U #>            [,1]        [,2]       [,3]       [,4] #> [1,]  0.1711751  0.09221058 0.78855772  0.5834150 #> [2,]  0.8605882 -0.33631329 0.12096045 -0.3628360 #> [3,]  0.2092122  0.91796420 0.08793762 -0.3253290 #> [4,] -0.4316449 -0.18902993 0.59650002 -0.6497215 VT #>            [,1]        [,2]        [,3] #> [1,]  0.2496213 -0.04136007  0.96745984 #> [2,]  0.1202120 -0.99003537 -0.07334196 #> [3,] -0.9608529 -0.13460796  0.24216198  rm(A,S,U,VT)  A = as.big.matrix(matrix(rnorm(12),4,3)) S = as.big.matrix(matrix(0,nrow=3,ncol=1)) U = as.big.matrix(matrix(0,nrow=4,ncol=4)) VT = as.big.matrix(matrix(0,ncol=3,nrow=3)) dgesdd(A=A,S=S,U=U,VT=VT) #> [1] 0 S[,] #> [1] 2.6819327 1.2859400 0.8128895 U[,] #>            [,1]       [,2]       [,3]        [,4] #> [1,] -0.1658242 -0.5205485 -0.3243924 -0.77220537 #> [2,]  0.4356896 -0.6461869 -0.3770659  0.50043820 #> [3,] -0.8648680 -0.1078115 -0.3028043  0.38560286 #> [4,] -0.1862263 -0.5475842  0.8129578  0.06760851 VT[,] #>           [,1]       [,2]       [,3] #> [1,] 0.5814564  0.0745909  0.8101510 #> [2,] 0.4372976  0.8110586 -0.3885289 #> [3,] 0.6860607 -0.5801897 -0.4389768  rm(A,S,U,VT) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1150951 61.5    2286010 122.1         NA  2286010 122.1 #> Vcells 2060435 15.8    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dhprod.html","id":null,"dir":"Reference","previous_headings":"","what":"Element-wise (Hadamard) product — dhprod","title":"Element-wise (Hadamard) product — dhprod","text":"Computes \\(Z := X \\circ Y\\). `Z` missing allocated automatically.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dhprod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Element-wise (Hadamard) product — dhprod","text":"","code":"dhprod(N = NULL, X, INCX = 1L, Y, INCY = 1L, Z, INCZ = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dhprod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Element-wise (Hadamard) product — dhprod","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`. Y Double-precision object updated place. INCY Integer stride traversing `Y`. Z Optional output container receiving product. INCZ Integer stride `Z`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dhprod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Element-wise (Hadamard) product — dhprod","text":"updated object `Z`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dhprod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Element-wise (Hadamard) product — dhprod","text":"","code":"dhprod(X = 1:4, Y = rep(2, 4)) #> [1] 2 4 6 8"},{"path":"https://fbertran.github.io/bigalgebra/reference/dnrm2.html","id":null,"dir":"Reference","previous_headings":"","what":"Euclidean norm (2-norm) — dnrm2","title":"Euclidean norm (2-norm) — dnrm2","text":"Euclidean norm (2-norm)","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dnrm2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Euclidean norm (2-norm) — dnrm2","text":"","code":"dnrm2(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dnrm2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Euclidean norm (2-norm) — dnrm2","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dnrm2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Euclidean norm (2-norm) — dnrm2","text":"Numeric scalar containing Euclidean norm.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":null,"dir":"Reference","previous_headings":"","what":"Cholesky factorization — dpotrf","title":"Cholesky factorization — dpotrf","text":"DPOTRF computes Cholesky factorization real symmetric positive definite matrix . factorization form = U**T * U,  UPLO = 'U', = L  * L**T,  UPLO = 'L', U upper triangular matrix L lower triangular. block version algorithm, calling Level 3 BLAS.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cholesky factorization — dpotrf","text":"","code":"dpotrf(UPLO = \"U\", N = NULL, A, LDA = NULL)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cholesky factorization — dpotrf","text":"UPLO character. 'U': Upper triangle stored; 'L': Lower triangle stored. N integer. order matrix .  N >= 0. big.matrix, dimension (LDA,N). LDA integer. Dimension array .  LDA >= max(1,N).","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cholesky factorization — dpotrf","text":"updates big matrix result, INFO integer = 0: successful exit < 0: INFO = -, -th argument illegal value > 0: INFO = , leading minor order positive definite, factorization completed. Terms laying computed triangle discarded.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cholesky factorization — dpotrf","text":"","code":"set.seed(4669) A = matrix(rnorm(16),4) B = as.big.matrix(A %*% t(A)) C = A %*% t(A) chol(C) #>           [,1]     [,2]       [,3]        [,4] #> [1,] 0.8840437 0.876387  1.9545734 -0.49320694 #> [2,] 0.0000000 2.139012 -0.8930167 -0.83237775 #> [3,] 0.0000000 0.000000  1.2194774 -0.68016374 #> [4,] 0.0000000 0.000000  0.0000000  0.05426794 dpotrf(UPLO='U', N=4, A=B, LDA=4) #> [1] 0 D <- B[,] D[lower.tri(D)]<-0 D #>           [,1]     [,2]       [,3]        [,4] #> [1,] 0.8840437 0.876387  1.9545734 -0.49320694 #> [2,] 0.0000000 2.139012 -0.8930167 -0.83237775 #> [3,] 0.0000000 0.000000  1.2194774 -0.68016374 #> [4,] 0.0000000 0.000000  0.0000000  0.05426794 D-chol(C) #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 t(D)%*%D-C #>      [,1]         [,2]         [,3] [,4] #> [1,]    0 0.000000e+00 0.000000e+00    0 #> [2,]    0 0.000000e+00 2.220446e-16    0 #> [3,]    0 2.220446e-16 0.000000e+00    0 #> [4,]    0 0.000000e+00 0.000000e+00    0  #' # The big.matrix file backings will be deleted when garbage collected. rm(A,B,C,D) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1151519 61.5    2286010 122.1         NA  2286010 122.1 #> Vcells 2061670 15.8    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dprdct.html","id":null,"dir":"Reference","previous_headings":"","what":"Product of vector elements — dprdct","title":"Product of vector elements — dprdct","text":"Product vector elements","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dprdct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Product of vector elements — dprdct","text":"","code":"dprdct(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dprdct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Product of vector elements — dprdct","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dprdct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Product of vector elements — dprdct","text":"Numeric scalar equal product elements `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dqddot.html","id":null,"dir":"Reference","previous_headings":"","what":"High-accuracy dot product — dqddot","title":"High-accuracy dot product — dqddot","text":"Forms dot product using long-double accumulation mitigate rounding error.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dqddot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"High-accuracy dot product — dqddot","text":"","code":"dqddot(N = NULL, X, INCX = 1L, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dqddot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"High-accuracy dot product — dqddot","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`. Y Double-precision object updated place. INCY Integer stride traversing `Y`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dqddot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"High-accuracy dot product — dqddot","text":"Numeric scalar equal dot product `X` `Y`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dqddot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"High-accuracy dot product — dqddot","text":"","code":"dqddot(X = 1:3, Y = c(2, 4, 6)) #> [1] 28"},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":null,"dir":"Reference","previous_headings":"","what":"Scales a vector by a constant. — dscal","title":"Scales a vector by a constant. — dscal","text":"Scales vector constant.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scales a vector by a constant. — dscal","text":"","code":"dscal(N = NULL, ALPHA, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scales a vector by a constant. — dscal","text":"N integer. Number elements input vector(s) ALPHA real number. scalar alpha Y big matrix scale ALPHA INCY integer. Storage spacing elements Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scales a vector by a constant. — dscal","text":"Update Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scales a vector by a constant. — dscal","text":"","code":"set.seed(4669) A = big.matrix(3, 2, type=\"double\", init=1, dimnames=list(NULL,  c(\"alpha\", \"beta\")), shared=FALSE) dscal(ALPHA=2,Y=A) #> An object of class \"big.matrix\" #> Slot \"address\": #> <pointer: 0x1266b9240> #>  A[,] #>      alpha beta #> [1,]     2    2 #> [2,]     2    2 #> [3,]     2    2  # The big.matrix file backings will be deleted when garbage collected. rm(A) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1152443 61.6    2286010 122.1         NA  2286010 122.1 #> Vcells 2063793 15.8    8388608  64.0      65536  6482741  49.5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dset.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill a vector or matrix with a constant value — dset","title":"Fill a vector or matrix with a constant value — dset","text":"Fill vector matrix constant value","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill a vector or matrix with a constant value — dset","text":"","code":"dset(N = NULL, ALPHA, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill a vector or matrix with a constant value — dset","text":"N Optional integer specifying number elements modify. Defaults length `X`. ALPHA Numeric scalar used populate `X`. X Double-precision vector, matrix [`bigmemory::big.matrix`] filled place. INCX Integer stride successive elements `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fill a vector or matrix with a constant value — dset","text":"Invisibly returns `X` modification.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill a vector or matrix with a constant value — dset","text":"","code":"x <- matrix(0, 2, 3) dset(ALPHA = 5, X = x) x #>      [,1] [,2] [,3] #> [1,]    5    5    5 #> [2,]    5    5    5"},{"path":"https://fbertran.github.io/bigalgebra/reference/dsqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Element-wise square root — dsqrt","title":"Element-wise square root — dsqrt","text":"Applies square root entry `X` place, supporting base R [`bigmemory::big.matrix`] inputs.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Element-wise square root — dsqrt","text":"","code":"dsqrt(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dsqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Element-wise square root — dsqrt","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Element-wise square root — dsqrt","text":"Invisibly returns modified object `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsqrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Element-wise square root — dsqrt","text":"","code":"vals <- matrix(c(1, 4, 9, 16), 2) dsqrt(X = vals) vals #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dsub.html","id":null,"dir":"Reference","previous_headings":"","what":"In-place vector subtraction — dsub","title":"In-place vector subtraction — dsub","text":"Updates `Y` subtracting `X`, .e. \\(Y := Y - X\\).","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"In-place vector subtraction — dsub","text":"","code":"dsub(N = NULL, X, INCX = 1L, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dsub.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"In-place vector subtraction — dsub","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`. Y Double-precision object updated place. INCY Integer stride traversing `Y`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"In-place vector subtraction — dsub","text":"Invisibly returns modified `Y`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsub.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"In-place vector subtraction — dsub","text":"","code":"x <- 1:4 y <- rep(10, 4) dsub(X = x, Y = y) y #> [1] 9 8 7 6"},{"path":"https://fbertran.github.io/bigalgebra/reference/dsum.html","id":null,"dir":"Reference","previous_headings":"","what":"Sum of elements — dsum","title":"Sum of elements — dsum","text":"Sum elements","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sum of elements — dsum","text":"","code":"dsum(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dsum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sum of elements — dsum","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sum of elements — dsum","text":"Numeric scalar giving sum elements `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":null,"dir":"Reference","previous_headings":"","what":"Swap two double-precision vectors. — dswap","title":"Swap two double-precision vectors. — dswap","text":"Exchange elements two double precision vectors place. = 0 N-1, swap DX(LX + * INCX) DY(LY + * INCY) LX LY depend increment signs. optimized BLAS available implementation dispatches DSWAP; otherwise portable C loop performs exchange.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swap two double-precision vectors. — dswap","text":"","code":"dswap(N = NULL, X, INCX = 1L, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swap two double-precision vectors. — dswap","text":"N Number elements input vectors. Defaults full length X NULL. X Double precision vector matrix providing first data block. INCX Storage spacing elements X. Y Double precision vector matrix providing second data block. INCY Storage spacing elements Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Swap two double-precision vectors. — dswap","text":"Invisibly returns NULL; X Y   modified place.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Swap two double-precision vectors. — dswap","text":"optimized BLAS available implementation delegates Fortran DSWAP routine. Otherwise portable C fallback performs exchange directly respecting supplied vector increments.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Swap two double-precision vectors. — dswap","text":"","code":"set.seed(4670) X <- matrix(runif(6), 3, 2) Y <- matrix(runif(6), 3, 2) X_original <- X Y_original <- Y dswap(X = X, Y = Y) all.equal(X, Y_original) #> [1] \"Mean relative difference: 0.274648\" all.equal(Y, X_original) #> [1] \"Mean relative difference: 0.2364376\""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsymm.html","id":null,"dir":"Reference","previous_headings":"","what":"Symmetric matrix-matrix multiplication — dsymm","title":"Symmetric matrix-matrix multiplication — dsymm","text":"Computes \\(C := \\alpha \\operatorname{op}() B + \\beta C\\) `` symmetric.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsymm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Symmetric matrix-matrix multiplication — dsymm","text":"","code":"dsymm(   SIDE = \"L\",   UPLO = \"U\",   M = NULL,   N = NULL,   ALPHA = 1,   A,   LDA = NULL,   B,   LDB = NULL,   BETA = 0,   C,   LDC = NULL )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dsymm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Symmetric matrix-matrix multiplication — dsymm","text":"SIDE Character specifying whether `` multiplies left (`\"L\"`) right (`\"R\"`). UPLO Character indicating whether `` stores upper (`\"U\"`) lower (`\"L\"`) triangle. M, N Optional integers output dimensions. ALPHA, BETA Numeric scalars. Symmetric matrix big.matrix. LDA, LDB, LDC Leading dimensions. B Input matrix. C Optional output container updated place.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsymm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Symmetric matrix-matrix multiplication — dsymm","text":"Invisibly returns `C`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dsymm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Symmetric matrix-matrix multiplication — dsymm","text":"","code":"A <- matrix(c(2, 1, 1, 3), 2, 2) B <- diag(2) C <- matrix(0, 2, 2) dsymm(A = A, B = B, C = C) C #>      [,1] [,2] #> [1,]    2    1 #> [2,]    1    3"},{"path":"https://fbertran.github.io/bigalgebra/reference/dvcal.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalised AXPBY operation — dvcal","title":"Generalised AXPBY operation — dvcal","text":"Computes linear combination \\(Y := \\alpha X + \\beta Y\\) place.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dvcal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalised AXPBY operation — dvcal","text":"","code":"dvcal(N = NULL, ALPHA = 1, X, INCX = 1L, BETA = 1, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dvcal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalised AXPBY operation — dvcal","text":"N Optional integer giving number elements. Defaults `length(X)`. ALPHA Numeric scalar multiplying `X`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`. BETA Numeric scalar multiplying `Y`. Y Double-precision object updated place. INCY Integer stride traversing `Y`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dvcal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalised AXPBY operation — dvcal","text":"Invisibly returns modified `Y`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dvcal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalised AXPBY operation — dvcal","text":"","code":"x <- 1:5 y <- rep(2, 5) dvcal(ALPHA = 2, X = x, BETA = -1, Y = y) y #> [1] 0 2 4 6 8"},{"path":"https://fbertran.github.io/bigalgebra/reference/dxyz.html","id":null,"dir":"Reference","previous_headings":"","what":"Three-dimensional cross product — dxyz","title":"Three-dimensional cross product — dxyz","text":"Three-dimensional cross product","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dxyz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Three-dimensional cross product — dxyz","text":"","code":"dxyz(X, Y, Z)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dxyz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Three-dimensional cross product — dxyz","text":"X Numeric vector length three, matrix three rows, big.matrix. Y Numeric object matching shape `X`. Z Optional output container.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dxyz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Three-dimensional cross product — dxyz","text":"updated object `Z` containing cross product.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dxyz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Three-dimensional cross product — dxyz","text":"","code":"dxyz(X = c(1, 0, 0), Y = c(0, 1, 0)) #> [1] 0 0 1"},{"path":"https://fbertran.github.io/bigalgebra/reference/idamax.html","id":null,"dir":"Reference","previous_headings":"","what":"Index of the maximum absolute value — idamax","title":"Index of the maximum absolute value — idamax","text":"Index maximum absolute value","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idamax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index of the maximum absolute value — idamax","text":"","code":"idamax(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/idamax.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index of the maximum absolute value — idamax","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idamax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index of the maximum absolute value — idamax","text":"Integer index (1-based).","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idamin.html","id":null,"dir":"Reference","previous_headings":"","what":"Index of the minimum absolute value — idamin","title":"Index of the minimum absolute value — idamin","text":"Index minimum absolute value","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idamin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index of the minimum absolute value — idamin","text":"","code":"idamin(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/idamin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index of the minimum absolute value — idamin","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idamin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index of the minimum absolute value — idamin","text":"Integer index (1-based).","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idmax.html","id":null,"dir":"Reference","previous_headings":"","what":"Index of the maximum element — idmax","title":"Index of the maximum element — idmax","text":"Index maximum element","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idmax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index of the maximum element — idmax","text":"","code":"idmax(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/idmax.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index of the maximum element — idmax","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idmax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index of the maximum element — idmax","text":"Integer index (1-based).","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idmin.html","id":null,"dir":"Reference","previous_headings":"","what":"Index of the minimum element — idmin","title":"Index of the minimum element — idmin","text":"Index minimum element","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idmin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index of the minimum element — idmin","text":"","code":"idmin(N = NULL, X, INCX = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/idmin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index of the minimum element — idmin","text":"N Optional integer giving number elements. Defaults `length(X)`. X Double-precision vector, matrix [`bigmemory::big.matrix`] input. INCX Integer stride traversing `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/idmin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index of the minimum element — idmin","text":"Integer index (1-based) smallest entry `X`.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-300","dir":"Changelog","previous_headings":"","what":"bigalgebra 3.0.0","title":"bigalgebra 3.0.0","text":"Added equivalent BLAS FORTRAN functions: DSET, DVCAL, DADD, DSUB, DSWAP, DDOT, DQDDOT, DHPROD, DXYZ, DSUM, DASUM, DNRM2, DPRDCT, IDMIN, IDMAX, IDAMIN, IDAMAX, DSYMM. precisely, wrappers call BLAS : dadd(), ddot(), dasum(), dnrm2() dsymm(). routines implemented explicit C++ loops. Added vignettes package Updated README Created dsqrt() helper wired C++ backend apply element-wise square roots double vectors, matrices, big.matrix objects place.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-202","dir":"Changelog","previous_headings":"","what":"bigalgebra 2.0.2","title":"bigalgebra 2.0.2","text":"CRAN release: 2025-09-08 Maintainer email update Code fix get rid random errors gcc 1.5 windows based.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-200","dir":"Changelog","previous_headings":"","what":"bigalgebra 2.0.0","title":"bigalgebra 2.0.0","text":"CRAN release: 2025-08-20 Code cleaning improvement. Bug fixes updates adapt new CRAN checks. Added tests","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-112","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.1.2","title":"bigalgebra 1.1.2","text":"CRAN release: 2024-09-23 Update adapt evolution CRAN checks.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-111","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.1.1","title":"bigalgebra 1.1.1","text":"CRAN release: 2023-12-09 Update adapt evolution CRAN checks.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-11","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.1","title":"bigalgebra 1.1","text":"Update FORTRAN calls requested CRAN R4.2.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-102","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.0.2","title":"bigalgebra 1.0.2","text":"recommended, updated link JSS.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-101","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.0.1","title":"bigalgebra 1.0.1","text":"CRAN release: 2021-05-12 Fixes CRAN checks Fedora.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-100","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.0.0","title":"bigalgebra 1.0.0","text":"CRAN release: 2021-04-18 Github actions, package logo, pkgdown site readme.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-090","dir":"Changelog","previous_headings":"","what":"bigalgebra 0.9.0","title":"bigalgebra 0.9.0","text":"Fixes CRAN check F. Bertrand.","code":""}]
