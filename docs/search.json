[{"path":"https://fbertran.github.io/bigalgebra/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Frederic Bertrand. Maintainer, contributor. Michael J. Kane. Author. Bryan Lewis. Author. John W. Emerson. Author.","code":""},{"path":"https://fbertran.github.io/bigalgebra/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Frederic Bertrand, Michael J. Kane, John Emerson Stephen Weston(2025). 'BLAS' 'LAPACK' Routines Native R Matrices 'big.matrix' Objects, R package version 2.1.0. doi:10.32614/CRAN.package.bigalgebra. Michael J. Kane, John Emerson, Stephen Weston (2013). Scalable Strategies Computing Massive Data. Journal Statistical Software, 55(14), 1-19. doi: 10.18637/jss.v055.i14.","code":"@Manual{,   title = {'BLAS' and 'LAPACK' Routines for Native R Matrices and 'big.matrix' Objects},   author = {Frederic Bertrand and Michael J. Kane and John Emerson and Stephen Weston},   publisher = {manual},   year = {2025},   note = {R package version 2.1.0},   url = {https://fbertran.github.io/bigalgebra/}, } @Article{,   title = {Scalable Strategies for Computing with Massive Data},   author = {Michael J. Kane and John Emerson and Stephen Weston},   journal = {Journal of Statistical Software},   volume = {55},   issue = {14},   pages = {20},   year = {2013},   doi = {10.18637/jss.v055.i14}, }"},{"path":[]},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"frédéric-bertrand-michael-j-kane-bryan-lewis-john-w-emerson","dir":"","previous_headings":"","what":"Frédéric Bertrand, Michael J. Kane, Bryan Lewis, John W. Emerson","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"https://doi.org/10.32614/CRAN.package.bigalgebra package provides arithmetic functions native R matrices bigmemory::big.matrix objects well functions QR factorization, Cholesky factorization, General eigenvalue, Singular value decomposition (SVD). method matrix multiplication arithmetic method -matrix addition, matrix difference- allows mixed type operation -matrix class object big.matrix class object- pure type operation two big.matrix class objects. package defines number global options begin bigalgebra. include: Option Default value * bigalgebra.temp_pattern default matrix_ * bigalgebra.tempdir default tempdir * bigalgebra.mixed_arithmetic_returns_R_matrix default TRUE * bigalgebra.DEBUG default FALSE bigalgebra.tempdir option must function returns temporary directory path used big matrix results BLAS LAPACK operations. deault value simply default R tempdir function. bigalgebra.temp_pattern name prefix file names generated big matrix objects output result BLAS LAPACK operations. bigalgebra.mixed_arithmetic_returns_R_matrix option determines whether arithmetic operations involving R matrix vector big.matrix matrix vector return big matrix (option FALSE), return normal R matrix (TRUE). package built, default, R’s native BLAS libraries, use 32-bit signed integer indexing. default build limited vectors 2^31 - 1 entries matrices 2^31 - 1 rows 2^31 - 1 columns (note standard R matrices limtied 2^31 - 1 total entries). package includes reference BLAS implementation supports 64-bit integer indexing, relaxing limitation vector lengths matrix row column limits. Installation package 64-bit reference BLAS implementation may performed command-line install: REFBLAS=1 R CMD INSTALL bigalgebra bigalgebra source package (example, bigalgebra_0.9.0.tar.gz). package may also build user-supplied external BLAS LAPACK libraries, either 32- 64-bit varieties. advanced topic requires additional Makevars modification, may include adjustment low-level calling syntax depending library used. Feel free contact us help installing running package. website, unit tests, C code fixes improvements well examples created F. Bertrand. Maintainer: Frédéric Bertrand frederic.bertrand@lecnam.net.","code":""},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"can install released version bigalgebra CRAN : can install development version bigalgebra github :","code":"install.packages(\"bigalgebra\") devtools::install_github(\"fbertran/bigalgebra\")"},{"path":"https://fbertran.github.io/bigalgebra/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"BLAS and LAPACK Routines for Native R Matrices and big.matrix Objects","text":"","code":"library(\"bigmemory\") A <- bigmemory::big.matrix(5,4,init = 1) B <- bigmemory::big.matrix(4,4,init = 2)  library(\"bigalgebra\") # Returns a new big.matrix object C <- A %*% B        # Compute the same thing in R D <- A[] %*% B[]     # Compare the results (subtraction of an R matrix from a big.matrix) print(C - D) #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #> [5,]    0    0    0    0  # The next example illustrates mixing R and big.matrix objects. It returns by # default (see # options(\"bigalgebra.mixed_arithmetic_returns_R_matrix\") D <- matrix(rnorm(16),4) E <- A %*% D"},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Arithmetic operations big.matrices","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"%*% signature{x=\"big.matrix\", y=\"big.matrix\"}: ... %*% signature{x=\"matrix\", y=\"big.matrix\"}: ... %*% signature{x=\"big.matrix\", y=\"matrix\"}: ... Arith signature{x=\"big.matrix\", y=\"big.matrix\"}: ... Arith signature{x=\"big.matrix\", y=\"matrix\"}: ... Arith signature{x=\"matrix\", y=\"big.matrix\"}: ... Arith signature{x=\"big.matrix\", y=\"numeric\"}: ... Arith signature{x=\"numeric\", y=\"big.matrix\"}: ...","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Class ","text":"Miscellaneous arithmetic methods matrices big.matrices. See also options(\"bigalgebra.mixed_arithmetic_returns_R_matrix\").","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/Ops.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class ","text":"B. W. Lewis <blewis@illposed.net>","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"package provides arithmetic functions native R matrices big.matrix objects.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"package provides arithmetic functions native R matrices big.matrix objects. package defines number global options begin bigalgebra. include: bigalgebra.tempdir option must function returns temporary directory path used big matrix results BLAS LAPACK operations. deault value simply default R tempdir function. bigalgebra.temp_pattern name prefix file names generated big matrix objects output result BLAS LAPACK operations. bigalgebra.mixed_arithmetic_returns_R_matrix option determines whether arithmetic operations involving R matrix vector big.matrix matrix vector return big matrix (option FALSE), return normal R matrix (TRUE). package built, default, R's native BLAS libraries, use 32-bit signed integer indexing. default build limited vectors 2**31 - 1 entries matrices 2**31 - 1 rows 2**31 - 1 columns (note standard R matrices limtied 2**31 - 1 total entries). package includes reference BLAS implementation supports 64-bit integer indexing, relaxing limitation vector lengths matrix row column limits. Installation package 64-bit reference BLAS implementation may performed command-line install: REFBLAS=1 R CMD INSTALL bigalgebra \"bigalgebra\" source package (example, bigalgebra_0.8.4.tar.gz). package may also build user-supplied external BLAS LAPACK libraries, either 32- 64-bit varieties. advanced topic requires additional Makevars modification, may include adjustment low-level calling syntax depending library used. Feel free contact us help installing running package.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"Frédéric Bertrand, Michael J. Kane, Bryan Lewis, John W. Emerson Maintainer: Frédéric Bertrand <frederic.bertrand@lecnam.net>","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"https://www.netlib.org/blas/ https://www.netlib.org/lapack/","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/reference/bigalgebra-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic routines for native R matrices and big.matrix objects. — bigalgebra-package","text":"","code":"# Testing the development of the user-friendly operators: # if you have any problems, please email us!  - Jay & Mike 4/29/2010  library(\"bigmemory\") A <- big.matrix(5,4, type=\"double\", init=0,                 dimnames=list(NULL, c(\"alpha\", \"beta\"))) B <- big.matrix(4,4, type=\"double\", init=0,                 dimnames=list(NULL, c(\"alpha\", \"beta\")))  C <- A  D <- A[]   print(C - D)       # Compare the results (subtraction of an R matrix from a #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 #> [5,]    0    0    0    0                    # big.matrix)  # The next example illustrates mixing R and big.matrix objects. It returns by # default (see # options(\"bigalgebra.mixed_arithmetic_returns_R_matrix\") D <- matrix(rnorm(16),4) E <- A"},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":null,"dir":"Reference","previous_headings":"","what":"Add two double-precision vectors. — dadd","title":"Add two double-precision vectors. — dadd","text":"Compute double precision DY := DX + DY N elements, applying specified storage increments. routine mirrors BLAS DAXPY operation unit scaling factor.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add two double-precision vectors. — dadd","text":"","code":"dadd(N = NULL, X, INCX = 1L, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add two double-precision vectors. — dadd","text":"N number elements input vectors. Defaults length X NULL. X double precision vector matrix providing addend. INCX storage spacing elements X. Y double precision vector matrix updated place. INCY storage spacing elements Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add two double-precision vectors. — dadd","text":"modified object Y containing element-wise sums.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add two double-precision vectors. — dadd","text":"implementation delegates BLAS DAXPY routine unit scaling factor, making equivalent daxpy(1.0, X, Y) exposing interface consistent low-level wrappers dcopy dscal.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dadd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add two double-precision vectors. — dadd","text":"","code":"set.seed(4669) X <- matrix(runif(6), 3, 2) Y <- matrix(runif(6), 3, 2) dadd(X = X, Y = Y) #>           [,1]     [,2] #> [1,] 0.8373056 1.273518 #> [2,] 0.9437275 1.347313 #> [3,] 1.0879022 1.192258 all.equal(Y, X + Y) #> [1] \"Mean relative difference: 0.5023438\""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":null,"dir":"Reference","previous_headings":"","what":"BLAS daxpy functionality — daxpy","title":"BLAS daxpy functionality — daxpy","text":"function implements function Y := * X + Y X Y may either native double-precision valued R matrices numeric vectors, double-precision valued big.matrix objects, scalar.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BLAS daxpy functionality — daxpy","text":"","code":"daxpy(A = 1, X, Y)"},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BLAS daxpy functionality — daxpy","text":"Optional numeric scalar value scale matrix X , default value 1. X Requried either native R matrix numeric vector, big.matrix object Y Optional native R matrix numeric vector, big.matrix object","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BLAS daxpy functionality — daxpy","text":"output value depends classes input values X Y value global option bigalgebra.mixed_arithmetic_returns_R_matrix. X Y big matrices, Y missing, options(\"bigalgebra.mixed_arithmetic_returns_R_matrix\") FALSE, big.matrix returned. returned big.matrix backed temporary file mapping deleted returned result garbage collected R (see examples). Otherwise, standard R matrix returned. dimensional shape output taken X. input X dimensionless (, lacks dimension attribute), output column vector.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BLAS daxpy functionality — daxpy","text":"least one either X Y must big.matrix. values must type double (type presently supported bigalgebra package). function rarely necessary use directly since bigalgebra package defines standard arithmetic operations scalar multiplication. efficient use daxpy directly scaling matrix addition required, case operations performed one step.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"BLAS daxpy functionality — daxpy","text":"https://www.netlib.org/blas/daxpy.f","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BLAS daxpy functionality — daxpy","text":"Michael J. Kane","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/daxpy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BLAS daxpy functionality — daxpy","text":"","code":"require(bigmemory) A = matrix(1, nrow=3, ncol=2) B <- big.matrix(3, 2, type=\"double\", init=0,                 dimnames=list(NULL, c(\"alpha\", \"beta\")), shared=FALSE) C = B + B   # C is a new big matrix D = A + B   # D defaults to a regular R matrix, to change this, set the option: # options(bigalgebra.mixed_arithmetic_returns_R_matrix=FALSE) E = daxpy(A=1.0, X=B, Y=B)  # Same kind of result as C print(C[]) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 print(D) #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #> [3,]    1    1 print(E[]) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0  # The C and E big.matrix file backings will be deleted when garbage collected: # (We enable debugging to see this explicitly) options(bigalgebra.DEBUG=TRUE) rm(C,E) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1145361 61.2    2289300 122.3         NA  2289300 122.3 #> Vcells 2051175 15.7    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy a vector. — dcopy","title":"Copy a vector. — dcopy","text":"Copy double precision DX double precision DY. = 0 N-1, copy DX(LX+*INCX) DY(LY+*INCY), LX = 1 INCX .GE. 0, else LX = 1+(1-N)*INCX, LY defined similar way using INCY.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy a vector. — dcopy","text":"","code":"dcopy(N = NULL, X, INCX = 1, Y, INCY = 1)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy a vector. — dcopy","text":"N number elements input vector(s) X double precision vector N elements INCX storage spacing elements DX Y double precision vector N elements INCY storage spacing elements DY","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy a vector. — dcopy","text":"DY copy vector DX (unchanged N .LE. 0)","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Copy a vector. — dcopy","text":"C. L. Lawson, R. J. Hanson, D. R. Kincaid F. T. Krogh, Basic linear algebra subprograms Fortran usage, Algorithm . 539, Transactions Mathematical Software 5, 3 (September 1979), pp. 308-323.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dcopy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copy a vector. — dcopy","text":"","code":"set.seed(4669) A = big.matrix(3, 2, type=\"double\", init=1, dimnames=list(NULL,  c(\"alpha\", \"beta\")), shared=FALSE) B = big.matrix(3, 2, type=\"double\", init=0, dimnames=list(NULL,  c(\"alpha\", \"beta\")), shared=FALSE)  dcopy(X=A,Y=B) #> [1] 0 A[,]-B[,] #>      alpha beta #> [1,]     0    0 #> [2,]     0    0 #> [3,]     0    0  # The big.matrix file backings will be deleted when garbage collected. rm(A,B) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1145301 61.2    2289300 122.3         NA  2289300 122.3 #> Vcells 2049909 15.7    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":null,"dir":"Reference","previous_headings":"","what":"DGEEV computes eigenvalues and eigenvectors. — dgeev","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"DGEEV computes eigenvalues , optionally, left /right eigenvectors GE matrices. DGEEV computes N--N real nonsymmetric matrix , eigenvalues , optionally, left /right eigenvectors. right eigenvector v(j) satisfies * v(j) = lambda(j) * v(j) lambda(j) eigenvalue. left eigenvector u(j) satisfies u(j)**H * = lambda(j) * u(j)**H u(j)**H denotes conjugate-transpose u(j). computed eigenvectors normalized Euclidean norm equal 1 largest component real.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"","code":"dgeev(   JOBVL = NULL,   JOBVR = NULL,   N = NULL,   A,   LDA = NULL,   WR,   WI,   VL = NULL,   LDVL = NULL,   VR = NULL,   LDVR = NULL,   WORK = NULL,   LWORK = NULL )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"JOBVL character. = 'N': left eigenvectors computed; = 'V': left eigenvectors computed. JOBVR character. = 'N': right eigenvectors computed; = 'V': right eigenvectors computed. N integer. order matrix . N >= 0. matrix dimension (LDA,N), N--N matrix . LDA integer. leading dimension matrix . LDA >= max(1,N). WR vector dimension (N). WR contain real part computed eigenvalues. Complex conjugate pairs eigenvalues appear consecutively eigenvalue positive imaginary part first. WI vector dimension (N). WI contain imaginary part computed eigenvalues. Complex conjugate pairs eigenvalues appear consecutively eigenvalue positive imaginary part first. VL matrx dimension (LDVL,N) JOBVL = 'V', left eigenvectors u(j) stored one   another columns VL, order   eigenvalues. JOBVL = 'N', VL referenced. j-th eigenvalue real, u(j) = VL(:,j),   j-th column VL. j-th (j+1)-st eigenvalues form complex   conjugate pair, u(j) = VL(:,j) + *VL(:,j+1)   u(j+1) = VL(:,j) - *VL(:,j+1). LDVL integer. leading dimension array VL. LDVL >= 1; JOBVL = 'V', LDVL >= N. VR matrix dimension (LDVR,N). JOBVR = 'V', right eigenvectors v(j) stored one another columns VR, order eigenvalues. JOBVR = 'N', VR referenced. j-th eigenvalue real, v(j) = VR(:,j), j-th column VR. j-th (j+1)-st eigenvalues form complex conjugate pair, v(j) = VR(:,j) + *VR(:,j+1) v(j+1) = VR(:,j) - *VR(:,j+1). LDVR integer. leading dimension array VR.  LDVR >= 1; JOBVR = 'V', LDVR >= N. WORK matrix dimension (MAX(1,LWORK)) LWORK integer. dimension array WORK.LWORK >= max(1,3*N), JOBVL = 'V' JOBVR = 'V', LWORK >= 4*N. good performance, LWORK must generally larger. LWORK = -1, workspace query assumed; routine calculates optimal size WORK array, returns value first entry WORK array, error message related LWORK issued XERBLA.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"WR, WI, VR, VL Work. exit, overwritten.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DGEEV computes eigenvalues and eigenvectors. — dgeev","text":"","code":"set.seed(4669) A = matrix(rnorm(16),4) WR= matrix(0,nrow=4,ncol=1) WI= matrix(0,nrow=4,ncol=1) VL = matrix(0,ncol=4,nrow=4) eigen(A) #> eigen() decomposition #> $values #> [1]  0.85730911+1.690442i  0.85730911-1.690442i -0.86120947+0.000000i #> [4] -0.04044732+0.000000i #>  #> $vectors #>                         [,1]                    [,2]          [,3] #> [1,] -0.20131416-0.08051662i -0.20131416+0.08051662i -0.4396218+0i #> [2,] -0.73251338+0.00000000i -0.73251338+0.00000000i  0.4547709+0i #> [3,] -0.06644069-0.55880008i -0.06644069+0.55880008i -0.1693250+0i #> [4,]  0.22714677+0.21942261i  0.22714677-0.21942261i -0.7558076+0i #>               [,4] #> [1,] -0.9125418+0i #> [2,] -0.2656930+0i #> [3,]  0.2527695+0i #> [4,]  0.1810590+0i #>  dgeev(A=A,WR=WR,WI=WI,VL=VL) #> [1] 0 VL #>              [,1]       [,2]       [,3]       [,4] #> [1,] -0.099694024  0.1149983 -0.2126753 -0.7057922 #> [2,]  0.657326284  0.0000000 -0.1918649  0.3331385 #> [3,]  0.007357843  0.5515939 -0.3234797  0.3139870 #> [4,]  0.451853982 -0.1904644 -0.9018414  0.5406369 WR #>             [,1] #> [1,]  0.85730911 #> [2,]  0.85730911 #> [3,] -0.86120947 #> [4,] -0.04044732 WI #>           [,1] #> [1,]  1.690442 #> [2,] -1.690442 #> [3,]  0.000000 #> [4,]  0.000000  rm(A,WR,WI,VL)  A = as.big.matrix(matrix(rnorm(16),4)) WR= matrix(0,nrow=4,ncol=1) WI= matrix(0,nrow=4,ncol=1) VL = as.big.matrix(matrix(0,ncol=4,nrow=4)) eigen(A[,]) #> eigen() decomposition #> $values #> [1] -0.7802559+0.6873447i -0.7802559-0.6873447i  0.6930662+0.4810716i #> [4]  0.6930662-0.4810716i #>  #> $vectors #>                       [,1]                  [,2]                   [,3] #> [1,]  0.1471182+0.4334710i  0.1471182-0.4334710i -0.2986975+0.07375248i #> [2,]  0.2638302+0.1607608i  0.2638302-0.1607608i -0.4446219-0.18640256i #> [3,] -0.4094915+0.0733955i -0.4094915-0.0733955i  0.7778787+0.00000000i #> [4,] -0.7224532+0.0000000i -0.7224532+0.0000000i  0.2526100-0.06323534i #>                        [,4] #> [1,] -0.2986975-0.07375248i #> [2,] -0.4446219+0.18640256i #> [3,]  0.7778787+0.00000000i #> [4,]  0.2526100+0.06323534i #>  dgeev(A=A,WR=WR,WI=WI,VL=VL) #> [1] 0 VL[,] #>             [,1]       [,2]        [,3]        [,4] #> [1,] -0.63149291  0.0000000 -0.35751797 -0.04531232 #> [2,] -0.22007417  0.1890068  0.81587447  0.00000000 #> [3,] -0.33976651  0.2889619  0.32444761  0.26761276 #> [4,] -0.08779556 -0.5571465  0.04124336 -0.16091204 WR[,] #> [1] -0.7802559 -0.7802559  0.6930662  0.6930662 WI[,] #> [1]  0.6873447 -0.6873447  0.4810716 -0.4810716  rm(A,WR,WI,VL) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1146572 61.3    2289300 122.3         NA  2289300 122.3 #> Vcells 2053145 15.7    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Multiply — dgemm","title":"Matrix Multiply — dgemm","text":"function provides dgemm functionality, DGEMM performs one matrix-matrix operations. C := ALPHA * op() * op(B) + BETA * C.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Multiply — dgemm","text":"","code":"dgemm(   TRANSA = \"N\",   TRANSB = \"N\",   M = NULL,   N = NULL,   K = NULL,   ALPHA = 1,   A,   LDA = NULL,   B,   LDB = NULL,   BETA = 0,   C,   LDC = NULL,   COFF = 0 )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Multiply — dgemm","text":"TRANSA character. TRANSA specifies form op( ) used matrix multiplication follows: TRANSA = 'N' 'n',  op( ) = . TRANSA = 'T' 't',  op( ) = **T. TRANSA = 'C' 'c',  op( ) = **T. TRANSB character. TRANSB specifies form op( B ) used matrix multiplication follows: #' TRANSA = 'N' 'n',  op( B ) = B. TRANSA = 'T' 't',  op( B ) = B**T. TRANSA = 'C' 'c',  op( B ) = B**T. M integer. M specifies number rows   matrix op( )   matrix  C.  M  must  least  zero. N integer. N specifies number columns   matrix op( B )   matrix  C.  N  must  least  zero. K integer. K specifies number columns   matrix op( )  number rows  matrix  op( B ).  K  must  least  zero. ALPHA real number. Specifies scalar alpha. matrix dimension (LDA, ka), ka k   TRANSA = 'N' 'n',   m  otherwise. entry  TRANSA = 'N' 'n',  leading  m k part array   must contain matrix  ,  otherwise leading  k m  part array   must contain  matrix . LDA integer. B matrix dimension ( LDB, kb ), kb n   TRANSB = 'N' 'n',   k  otherwise. entry  TRANSB = 'N' 'n',  leading  k n part array  B  must contain matrix  B,  otherwise leading  n k  part array  B  must contain  matrix B. LDB integer. BETA real number. Specifies scalar beta C matrix dimension ( LDC, N ). entry, leading  m n  part array  C must contain matrix  C,  except  beta  zero, case C need set entry. exit, array  C  overwritten  m n  matrix ( alpha*op( )*op( B ) + beta*C ). LDC integer. COFF offset C.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Multiply — dgemm","text":"Update C result.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgemm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Multiply — dgemm","text":"","code":"require(bigmemory) A = as.big.matrix(matrix(1, nrow=3, ncol=2)) B <- big.matrix(2, 3, type=\"double\", init=-1,                 dimnames=list(NULL, c(\"alpha\", \"beta\")), shared=FALSE) C = big.matrix(3, 3, type=\"double\", init=1,                dimnames=list(NULL, c(\"alpha\", \"beta\", \"gamma\")), shared=FALSE)   2*A[,]%*%B[,]+0.5*C[,] #>      alpha beta gamma #> [1,]  -3.5 -3.5  -3.5 #> [2,]  -3.5 -3.5  -3.5 #> [3,]  -3.5 -3.5  -3.5 E = dgemm(ALPHA=2.0, A=A, B=B, BETA=0.5, C=C) E[,] # Same result #>      alpha beta gamma #> [1,]  -3.5 -3.5  -3.5 #> [2,]  -3.5 -3.5  -3.5 #> [3,]  -3.5 -3.5  -3.5  # The big.matrix file backings will be deleted when garbage collected. rm(A,B,C,E) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1146865 61.3    2289300 122.3         NA  2289300 122.3 #> Vcells 2053648 15.7    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":null,"dir":"Reference","previous_headings":"","what":"QR factorization — dgeqrf","title":"QR factorization — dgeqrf","text":"DGEQRF computes QR factorization real M--N matrix : = Q * R.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"QR factorization — dgeqrf","text":"","code":"dgeqrf(   M = NULL,   N = NULL,   A,   LDA = NULL,   TAU = NULL,   WORK = NULL,   LWORK = NULL )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"QR factorization — dgeqrf","text":"M integer. number rows matrix .  M >= 0. N integer. number columns matrix .  N >= 0. M--N big matrix . LDA integer. leading dimension array .  LDA >= max(1,M). TAU min(M,N) matrix. scalar factors elementary reflectors. WORK (MAX(1,LWORK)) matrix. exit, INFO = 0, WORK(1) returns optimal LWORK. LWORK integer. dimension th array WORK.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"QR factorization — dgeqrf","text":"M--N big matrix . elements diagonal array contain min(M,N)--N upper trapezoidal matrix R (R upper triangular m >= n); elements diagonal, array TAU, represent orthogonal matrix Q product min(m,n) elementary reflectors.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgeqrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"QR factorization — dgeqrf","text":"","code":"hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, \"+\") } h9 <- hilbert(9); h9 #>            [,1]      [,2]       [,3]       [,4]       [,5]       [,6] #>  [1,] 1.0000000 0.5000000 0.33333333 0.25000000 0.20000000 0.16666667 #>  [2,] 0.5000000 0.3333333 0.25000000 0.20000000 0.16666667 0.14285714 #>  [3,] 0.3333333 0.2500000 0.20000000 0.16666667 0.14285714 0.12500000 #>  [4,] 0.2500000 0.2000000 0.16666667 0.14285714 0.12500000 0.11111111 #>  [5,] 0.2000000 0.1666667 0.14285714 0.12500000 0.11111111 0.10000000 #>  [6,] 0.1666667 0.1428571 0.12500000 0.11111111 0.10000000 0.09090909 #>  [7,] 0.1428571 0.1250000 0.11111111 0.10000000 0.09090909 0.08333333 #>  [8,] 0.1250000 0.1111111 0.10000000 0.09090909 0.08333333 0.07692308 #>  [9,] 0.1111111 0.1000000 0.09090909 0.08333333 0.07692308 0.07142857 #>             [,7]       [,8]       [,9] #>  [1,] 0.14285714 0.12500000 0.11111111 #>  [2,] 0.12500000 0.11111111 0.10000000 #>  [3,] 0.11111111 0.10000000 0.09090909 #>  [4,] 0.10000000 0.09090909 0.08333333 #>  [5,] 0.09090909 0.08333333 0.07692308 #>  [6,] 0.08333333 0.07692308 0.07142857 #>  [7,] 0.07692308 0.07142857 0.06666667 #>  [8,] 0.07142857 0.06666667 0.06250000 #>  [9,] 0.06666667 0.06250000 0.05882353 qr(h9)$rank           #--> only 7 #> [1] 7 qrh9 <- qr(h9, tol = 1e-10) qrh9$rank  #> [1] 9 C <- as.big.matrix(h9) dgeqrf(A=C) #> [1] 0  # The big.matrix file backings will be deleted when garbage collected. rm(C) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1147731 61.3    2289300 122.3         NA  2289300 122.3 #> Vcells 2055841 15.7    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":null,"dir":"Reference","previous_headings":"","what":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"DGESDD computes singular value decomposition (SVD) real M--N matrix , optionally computing left right singular vectors.  singular vectors desired, uses divide--conquer algorithm. SVD written = U * SIGMA * transpose(V) SIGMA M--N matrix zero except min(m,n) diagonal elements, U M--M orthogonal matrix, V N--N orthogonal matrix.  diagonal elements SIGMA singular values ; real non-negative, returned descending order.  first min(m,n) columns U V left right singular vectors . Note routine returns VT = V**T, V.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"","code":"dgesdd(   JOBZ = \"A\",   M = NULL,   N = NULL,   A,   LDA = NULL,   S,   U,   LDU = NULL,   VT,   LDVT = NULL,   WORK = NULL,   LWORK = NULL )"},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"JOBZ character. Specifies options computing part matrix U: = '': M columns U N rows V**T returned arrays U VT; = 'S': first min(M,N) columns U first min(M,N) rows V**T returned arrays U VT; = 'O': M >= N, first N columns U overwritten array rows V**T returned array VT; otherwise, columns U returned array U first M rows V**T overwritten array ; = 'N': columns U rows V**T computed. M integer. number rows input matrix . M >= 0. N integer. number columns input matrix . N >= 0. M--N matrix . LDA integer. leading dimension matrix .  LDA >= max(1,M). S matrix dimension (min(M,N)). singular values , sorted S() >= S(+1). U U matrx dimension (LDU,UCOL) UCOL = M JOBZ = '' JOBZ = 'O' M < N; UCOL = min(M,N) JOBZ = 'S'. JOBZ = '' JOBZ = 'O' M < N, U contains M--M orthogonal matrix U; JOBZ = 'S', U contains first min(M,N) columns U (left singular vectors, stored columnwise); JOBZ = 'O' M >= N, JOBZ = 'N', U referenced. LDU integer. leading dimension matrix U.  LDU >= 1; JOBZ = 'S' '' JOBZ = 'O' M < N, LDU >= M. VT VT matrix dimension (LDVT,N) JOBZ = '' JOBZ = 'O' M >= N, VT contains N--N orthogonal matrix V**T; JOBZ = 'S', VT contains first min(M,N) rows V**T (right singular vectors, stored rowwise); JOBZ = 'O' M < N, JOBZ = 'N', VT referenced. LDVT integer. leading dimension matrix VT.  LDVT >= 1; JOBZ = '' JOBZ = 'O' M >= N, LDVT >= N; JOBZ = 'S', LDVT >= min(M,N). WORK matrix dimension (MAX(1,LWORK)) LWORK integer. dimension array WORK. LWORK >= 1. LWORK = -1, workspace query assumed.  optimal size WORK array calculated stored WORK(1), work except argument checking performed. Let mx = max(M,N) mn = min(M,N). JOBZ = 'N', LWORK >= 3*mn + max( mx, 7*mn ). JOBZ = 'O', LWORK >= 3*mn + max( mx, 5*mn*mn + 4*mn ). JOBZ = 'S', LWORK >= 4*mn*mn + 7*mn. JOBZ = '', LWORK >= 4*mn*mn + 6*mn + mx. tight minimums cases; see comments inside code.  good performance, LWORK generally larger;  query recommended.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"IWORK integer matrix dimension (8*min(M,N)) updated. JOBZ = 'O',  overwritten first N columns U (left singular vectors, stored columnwise) M >= N; overwritten first M rows V**T (right singular vectors, stored rowwise) otherwise. JOBZ .ne. 'O', contents destroyed. INFO integer = 0: successful exit. < 0: INFO = -, -th argument illegal value. > 0: DBDSDC converge, updating process failed.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dgesdd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DGESDD computes the singular value decomposition (SVD) of a real matrix. — dgesdd","text":"","code":"set.seed(4669) A = matrix(rnorm(12),4,3) S = matrix(0,nrow=3,ncol=1) U = matrix(0,nrow=4,ncol=4) VT = matrix(0,ncol=3,nrow=3) dgesdd(A=A,S=S,U=U,VT=VT) #> [1] 0 S #>           [,1] #> [1,] 2.5683690 #> [2,] 1.9865047 #> [3,] 0.1726739 U #>            [,1]        [,2]       [,3]       [,4] #> [1,]  0.1711751  0.09221058 0.78855772  0.5834150 #> [2,]  0.8605882 -0.33631329 0.12096045 -0.3628360 #> [3,]  0.2092122  0.91796420 0.08793762 -0.3253290 #> [4,] -0.4316449 -0.18902993 0.59650002 -0.6497215 VT #>            [,1]        [,2]        [,3] #> [1,]  0.2496213 -0.04136007  0.96745984 #> [2,]  0.1202120 -0.99003537 -0.07334196 #> [3,] -0.9608529 -0.13460796  0.24216198  rm(A,S,U,VT)  A = as.big.matrix(matrix(rnorm(12),4,3)) S = as.big.matrix(matrix(0,nrow=3,ncol=1)) U = as.big.matrix(matrix(0,nrow=4,ncol=4)) VT = as.big.matrix(matrix(0,ncol=3,nrow=3)) dgesdd(A=A,S=S,U=U,VT=VT) #> [1] 0 S[,] #> [1] 2.6819327 1.2859400 0.8128895 U[,] #>            [,1]       [,2]       [,3]        [,4] #> [1,] -0.1658242 -0.5205485 -0.3243924 -0.77220537 #> [2,]  0.4356896 -0.6461869 -0.3770659  0.50043820 #> [3,] -0.8648680 -0.1078115 -0.3028043  0.38560286 #> [4,] -0.1862263 -0.5475842  0.8129578  0.06760851 VT[,] #>           [,1]       [,2]       [,3] #> [1,] 0.5814564  0.0745909  0.8101510 #> [2,] 0.4372976  0.8110586 -0.3885289 #> [3,] 0.6860607 -0.5801897 -0.4389768  rm(A,S,U,VT) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1148403 61.4    2289300 122.3         NA  2289300 122.3 #> Vcells 2057135 15.7    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":null,"dir":"Reference","previous_headings":"","what":"Cholesky factorization — dpotrf","title":"Cholesky factorization — dpotrf","text":"DPOTRF computes Cholesky factorization real symmetric positive definite matrix . factorization form = U**T * U,  UPLO = 'U', = L  * L**T,  UPLO = 'L', U upper triangular matrix L lower triangular. block version algorithm, calling Level 3 BLAS.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cholesky factorization — dpotrf","text":"","code":"dpotrf(UPLO = \"U\", N = NULL, A, LDA = NULL)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cholesky factorization — dpotrf","text":"UPLO character. 'U': Upper triangle stored; 'L': Lower triangle stored. N integer. order matrix .  N >= 0. big.matrix, dimension (LDA,N). LDA integer. Dimension array .  LDA >= max(1,N).","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cholesky factorization — dpotrf","text":"updates big matrix result, INFO integer = 0: successful exit < 0: INFO = -, -th argument illegal value > 0: INFO = , leading minor order positive definite, factorization completed. Terms laying computed triangle discarded.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dpotrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cholesky factorization — dpotrf","text":"","code":"set.seed(4669) A = matrix(rnorm(16),4) B = as.big.matrix(A %*% t(A)) C = A %*% t(A) chol(C) #>           [,1]     [,2]       [,3]        [,4] #> [1,] 0.8840437 0.876387  1.9545734 -0.49320694 #> [2,] 0.0000000 2.139012 -0.8930167 -0.83237775 #> [3,] 0.0000000 0.000000  1.2194774 -0.68016374 #> [4,] 0.0000000 0.000000  0.0000000  0.05426794 dpotrf(UPLO='U', N=4, A=B, LDA=4) #> [1] 0 D <- B[,] D[lower.tri(D)]<-0 D #>           [,1]     [,2]       [,3]        [,4] #> [1,] 0.8840437 0.876387  1.9545734 -0.49320694 #> [2,] 0.0000000 2.139012 -0.8930167 -0.83237775 #> [3,] 0.0000000 0.000000  1.2194774 -0.68016374 #> [4,] 0.0000000 0.000000  0.0000000  0.05426794 D-chol(C) #>      [,1] [,2] [,3] [,4] #> [1,]    0    0    0    0 #> [2,]    0    0    0    0 #> [3,]    0    0    0    0 #> [4,]    0    0    0    0 t(D)%*%D-C #>      [,1]         [,2]         [,3] [,4] #> [1,]    0 0.000000e+00 0.000000e+00    0 #> [2,]    0 0.000000e+00 2.220446e-16    0 #> [3,]    0 2.220446e-16 0.000000e+00    0 #> [4,]    0 0.000000e+00 0.000000e+00    0  #' # The big.matrix file backings will be deleted when garbage collected. rm(A,B,C,D) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1148549 61.4    2289300 122.3         NA  2289300 122.3 #> Vcells 2057382 15.7    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":null,"dir":"Reference","previous_headings":"","what":"Scales a vector by a constant. — dscal","title":"Scales a vector by a constant. — dscal","text":"Scales vector constant.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scales a vector by a constant. — dscal","text":"","code":"dscal(N = NULL, ALPHA, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scales a vector by a constant. — dscal","text":"N integer. Number elements input vector(s) ALPHA real number. scalar alpha Y big matrix scale ALPHA INCY integer. Storage spacing elements Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scales a vector by a constant. — dscal","text":"Update Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dscal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scales a vector by a constant. — dscal","text":"","code":"set.seed(4669) A = big.matrix(3, 2, type=\"double\", init=1, dimnames=list(NULL,  c(\"alpha\", \"beta\")), shared=FALSE) dscal(ALPHA=2,Y=A) #> An object of class \"big.matrix\" #> Slot \"address\": #> <pointer: 0x111c38a10> #>  A[,] #>      alpha beta #> [1,]     2    2 #> [2,]     2    2 #> [3,]     2    2  # The big.matrix file backings will be deleted when garbage collected. rm(A) gc() #>           used (Mb) gc trigger  (Mb) limit (Mb) max used  (Mb) #> Ncells 1149172 61.4    2289300 122.3         NA  2289300 122.3 #> Vcells 2058926 15.8    8388608  64.0      65536  5287195  40.4"},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":null,"dir":"Reference","previous_headings":"","what":"Swap two double-precision vectors. — dswap","title":"Swap two double-precision vectors. — dswap","text":"Exchange elements two double precision vectors place. = 0 N-1, swap DX(LX + * INCX) DY(LY + * INCY) LX LY depend increment signs. optimized BLAS available implementation dispatches DSWAP; otherwise portable C loop performs exchange.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swap two double-precision vectors. — dswap","text":"","code":"dswap(N = NULL, X, INCX = 1L, Y, INCY = 1L)"},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swap two double-precision vectors. — dswap","text":"N Number elements input vectors. Defaults full length X NULL. X Double precision vector matrix providing first data block. INCX Storage spacing elements X. Y Double precision vector matrix providing second data block. INCY Storage spacing elements Y.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Swap two double-precision vectors. — dswap","text":"Invisibly returns NULL; X Y   modified place.","code":""},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Swap two double-precision vectors. — dswap","text":"optimized BLAS available implementation delegates Fortran DSWAP routine. Otherwise portable C fallback performs exchange directly respecting supplied vector increments.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigalgebra/reference/dswap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Swap two double-precision vectors. — dswap","text":"","code":"set.seed(4670) X <- matrix(runif(6), 3, 2) Y <- matrix(runif(6), 3, 2) X_original <- X Y_original <- Y dswap(X = X, Y = Y) all.equal(X, Y_original) #> [1] \"Mean relative difference: 0.274648\" all.equal(Y, X_original) #> [1] \"Mean relative difference: 0.2364376\""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-210","dir":"Changelog","previous_headings":"","what":"bigalgebra 2.1.0","title":"bigalgebra 2.1.0","text":"Added dadd dswap wrappers","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-202","dir":"Changelog","previous_headings":"","what":"bigalgebra 2.0.2","title":"bigalgebra 2.0.2","text":"CRAN release: 2025-09-08 Maintainer email update Code fix get rid random errors gcc 1.5 windows based.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-200","dir":"Changelog","previous_headings":"","what":"bigalgebra 2.0.0","title":"bigalgebra 2.0.0","text":"CRAN release: 2025-08-20 Code cleaning improvement. Bug fixes updates adapt new CRAN checks. Added tests","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-112","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.1.2","title":"bigalgebra 1.1.2","text":"CRAN release: 2024-09-23 Update adapt evolution CRAN checks.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-111","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.1.1","title":"bigalgebra 1.1.1","text":"CRAN release: 2023-12-09 Update adapt evolution CRAN checks.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-11","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.1","title":"bigalgebra 1.1","text":"Update FORTRAN calls requested CRAN R4.2.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-102","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.0.2","title":"bigalgebra 1.0.2","text":"recommended, updated link JSS.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-101","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.0.1","title":"bigalgebra 1.0.1","text":"CRAN release: 2021-05-12 Fixes CRAN checks Fedora.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-100","dir":"Changelog","previous_headings":"","what":"bigalgebra 1.0.0","title":"bigalgebra 1.0.0","text":"CRAN release: 2021-04-18 Github actions, package logo, pkgdown site readme.","code":""},{"path":"https://fbertran.github.io/bigalgebra/news/index.html","id":"bigalgebra-090","dir":"Changelog","previous_headings":"","what":"bigalgebra 0.9.0","title":"bigalgebra 0.9.0","text":"Fixes CRAN check F. Bertrand.","code":""}]
